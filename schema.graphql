schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
columns and relationships of "boat.agents"
"""
type agents {
  commission: Int!
  created_at: timestamptz!
  default_pickup_location: String!
  email: String!
  id: String!
  organization: String!
  password: String!
  updated_at: timestamptz!
  username: String!
}

"""
aggregated selection of "boat.agents"
"""
type agents_aggregate {
  aggregate: agents_aggregate_fields
  nodes: [agents!]!
}

"""
aggregate fields of "boat.agents"
"""
type agents_aggregate_fields {
  avg: agents_avg_fields
  count(columns: [agents_select_column!], distinct: Boolean): Int
  max: agents_max_fields
  min: agents_min_fields
  stddev: agents_stddev_fields
  stddev_pop: agents_stddev_pop_fields
  stddev_samp: agents_stddev_samp_fields
  sum: agents_sum_fields
  var_pop: agents_var_pop_fields
  var_samp: agents_var_samp_fields
  variance: agents_variance_fields
}

"""
order by aggregate values of table "boat.agents"
"""
input agents_aggregate_order_by {
  avg: agents_avg_order_by
  count: order_by
  max: agents_max_order_by
  min: agents_min_order_by
  stddev: agents_stddev_order_by
  stddev_pop: agents_stddev_pop_order_by
  stddev_samp: agents_stddev_samp_order_by
  sum: agents_sum_order_by
  var_pop: agents_var_pop_order_by
  var_samp: agents_var_samp_order_by
  variance: agents_variance_order_by
}

"""
input type for inserting array relation for remote table "boat.agents"
"""
input agents_arr_rel_insert_input {
  data: [agents_insert_input!]!
  on_conflict: agents_on_conflict
}

"""aggregate avg on columns"""
type agents_avg_fields {
  commission: Float
}

"""
order by avg() on columns of table "boat.agents"
"""
input agents_avg_order_by {
  commission: order_by
}

"""
Boolean expression to filter rows from the table "boat.agents". All fields are combined with a logical 'AND'.
"""
input agents_bool_exp {
  _and: [agents_bool_exp]
  _not: agents_bool_exp
  _or: [agents_bool_exp]
  commission: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  default_pickup_location: String_comparison_exp
  email: String_comparison_exp
  id: String_comparison_exp
  organization: String_comparison_exp
  password: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  username: String_comparison_exp
}

"""
unique or primary key constraints on table "boat.agents"
"""
enum agents_constraint {
  """unique or primary key constraint"""
  agents_pkey

  """unique or primary key constraint"""
  agents_username_key
}

"""
input type for incrementing integer column in table "boat.agents"
"""
input agents_inc_input {
  commission: Int
}

"""
input type for inserting data into table "boat.agents"
"""
input agents_insert_input {
  commission: Int
  created_at: timestamptz
  default_pickup_location: String
  email: String
  id: String
  organization: String
  password: String
  updated_at: timestamptz
  username: String
}

"""aggregate max on columns"""
type agents_max_fields {
  commission: Int
  created_at: timestamptz
  default_pickup_location: String
  email: String
  id: String
  organization: String
  password: String
  updated_at: timestamptz
  username: String
}

"""
order by max() on columns of table "boat.agents"
"""
input agents_max_order_by {
  commission: order_by
  created_at: order_by
  default_pickup_location: order_by
  email: order_by
  id: order_by
  organization: order_by
  password: order_by
  updated_at: order_by
  username: order_by
}

"""aggregate min on columns"""
type agents_min_fields {
  commission: Int
  created_at: timestamptz
  default_pickup_location: String
  email: String
  id: String
  organization: String
  password: String
  updated_at: timestamptz
  username: String
}

"""
order by min() on columns of table "boat.agents"
"""
input agents_min_order_by {
  commission: order_by
  created_at: order_by
  default_pickup_location: order_by
  email: order_by
  id: order_by
  organization: order_by
  password: order_by
  updated_at: order_by
  username: order_by
}

"""
response of any mutation on the table "boat.agents"
"""
type agents_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [agents!]!
}

"""
input type for inserting object relation for remote table "boat.agents"
"""
input agents_obj_rel_insert_input {
  data: agents_insert_input!
  on_conflict: agents_on_conflict
}

"""
on conflict condition type for table "boat.agents"
"""
input agents_on_conflict {
  constraint: agents_constraint!
  update_columns: [agents_update_column!]!
  where: agents_bool_exp
}

"""
ordering options when selecting data from "boat.agents"
"""
input agents_order_by {
  commission: order_by
  created_at: order_by
  default_pickup_location: order_by
  email: order_by
  id: order_by
  organization: order_by
  password: order_by
  updated_at: order_by
  username: order_by
}

"""
primary key columns input for table: "boat.agents"
"""
input agents_pk_columns_input {
  id: String!
}

"""
select columns of table "boat.agents"
"""
enum agents_select_column {
  """column name"""
  commission

  """column name"""
  created_at

  """column name"""
  default_pickup_location

  """column name"""
  email

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  password

  """column name"""
  updated_at

  """column name"""
  username
}

"""
input type for updating data in table "boat.agents"
"""
input agents_set_input {
  commission: Int
  created_at: timestamptz
  default_pickup_location: String
  email: String
  id: String
  organization: String
  password: String
  updated_at: timestamptz
  username: String
}

"""aggregate stddev on columns"""
type agents_stddev_fields {
  commission: Float
}

"""
order by stddev() on columns of table "boat.agents"
"""
input agents_stddev_order_by {
  commission: order_by
}

"""aggregate stddev_pop on columns"""
type agents_stddev_pop_fields {
  commission: Float
}

"""
order by stddev_pop() on columns of table "boat.agents"
"""
input agents_stddev_pop_order_by {
  commission: order_by
}

"""aggregate stddev_samp on columns"""
type agents_stddev_samp_fields {
  commission: Float
}

"""
order by stddev_samp() on columns of table "boat.agents"
"""
input agents_stddev_samp_order_by {
  commission: order_by
}

"""aggregate sum on columns"""
type agents_sum_fields {
  commission: Int
}

"""
order by sum() on columns of table "boat.agents"
"""
input agents_sum_order_by {
  commission: order_by
}

"""
update columns of table "boat.agents"
"""
enum agents_update_column {
  """column name"""
  commission

  """column name"""
  created_at

  """column name"""
  default_pickup_location

  """column name"""
  email

  """column name"""
  id

  """column name"""
  organization

  """column name"""
  password

  """column name"""
  updated_at

  """column name"""
  username
}

"""aggregate var_pop on columns"""
type agents_var_pop_fields {
  commission: Float
}

"""
order by var_pop() on columns of table "boat.agents"
"""
input agents_var_pop_order_by {
  commission: order_by
}

"""aggregate var_samp on columns"""
type agents_var_samp_fields {
  commission: Float
}

"""
order by var_samp() on columns of table "boat.agents"
"""
input agents_var_samp_order_by {
  commission: order_by
}

"""aggregate variance on columns"""
type agents_variance_fields {
  commission: Float
}

"""
order by variance() on columns of table "boat.agents"
"""
input agents_variance_order_by {
  commission: order_by
}

"""
columns and relationships of "boat.attractions"
"""
type attractions {
  """An object relationship"""
  city: city
  city_id: String
  created_at: timestamptz
  id: String!
  name: String!

  """An array relationship"""
  products_attractions(
    """distinct select on columns"""
    distinct_on: [products_attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_attractions_order_by!]

    """filter the rows returned"""
    where: products_attractions_bool_exp
  ): [products_attractions!]!

  """An aggregated array relationship"""
  products_attractions_aggregate(
    """distinct select on columns"""
    distinct_on: [products_attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_attractions_order_by!]

    """filter the rows returned"""
    where: products_attractions_bool_exp
  ): products_attractions_aggregate!
  questions(
    """JSON select path"""
    path: String
  ): jsonb
  updated_at: timestamptz
}

"""
aggregated selection of "boat.attractions"
"""
type attractions_aggregate {
  aggregate: attractions_aggregate_fields
  nodes: [attractions!]!
}

"""
aggregate fields of "boat.attractions"
"""
type attractions_aggregate_fields {
  count(columns: [attractions_select_column!], distinct: Boolean): Int
  max: attractions_max_fields
  min: attractions_min_fields
}

"""
order by aggregate values of table "boat.attractions"
"""
input attractions_aggregate_order_by {
  count: order_by
  max: attractions_max_order_by
  min: attractions_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input attractions_append_input {
  questions: jsonb
}

"""
input type for inserting array relation for remote table "boat.attractions"
"""
input attractions_arr_rel_insert_input {
  data: [attractions_insert_input!]!
  on_conflict: attractions_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.attractions". All fields are combined with a logical 'AND'.
"""
input attractions_bool_exp {
  _and: [attractions_bool_exp]
  _not: attractions_bool_exp
  _or: [attractions_bool_exp]
  city: city_bool_exp
  city_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  products_attractions: products_attractions_bool_exp
  questions: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "boat.attractions"
"""
enum attractions_constraint {
  """unique or primary key constraint"""
  attractions_name_key

  """unique or primary key constraint"""
  attractions_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input attractions_delete_at_path_input {
  questions: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input attractions_delete_elem_input {
  questions: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input attractions_delete_key_input {
  questions: String
}

"""
input type for inserting data into table "boat.attractions"
"""
input attractions_insert_input {
  city: city_obj_rel_insert_input
  city_id: String
  created_at: timestamptz
  id: String
  name: String
  products_attractions: products_attractions_arr_rel_insert_input
  questions: jsonb
  updated_at: timestamptz
}

"""aggregate max on columns"""
type attractions_max_fields {
  city_id: String
  created_at: timestamptz
  id: String
  name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "boat.attractions"
"""
input attractions_max_order_by {
  city_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type attractions_min_fields {
  city_id: String
  created_at: timestamptz
  id: String
  name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "boat.attractions"
"""
input attractions_min_order_by {
  city_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "boat.attractions"
"""
type attractions_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [attractions!]!
}

"""
input type for inserting object relation for remote table "boat.attractions"
"""
input attractions_obj_rel_insert_input {
  data: attractions_insert_input!
  on_conflict: attractions_on_conflict
}

"""
on conflict condition type for table "boat.attractions"
"""
input attractions_on_conflict {
  constraint: attractions_constraint!
  update_columns: [attractions_update_column!]!
  where: attractions_bool_exp
}

"""
ordering options when selecting data from "boat.attractions"
"""
input attractions_order_by {
  city: city_order_by
  city_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  products_attractions_aggregate: products_attractions_aggregate_order_by
  questions: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "boat.attractions"
"""
input attractions_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input attractions_prepend_input {
  questions: jsonb
}

"""
select columns of table "boat.attractions"
"""
enum attractions_select_column {
  """column name"""
  city_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  questions

  """column name"""
  updated_at
}

"""
input type for updating data in table "boat.attractions"
"""
input attractions_set_input {
  city_id: String
  created_at: timestamptz
  id: String
  name: String
  questions: jsonb
  updated_at: timestamptz
}

"""
update columns of table "boat.attractions"
"""
enum attractions_update_column {
  """column name"""
  city_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  questions

  """column name"""
  updated_at
}

"""
columns and relationships of "boat.availabilities"
"""
type availabilities {
  """An object relationship"""
  availabilities_group: availabilities_group
  availabilities_group_id: String
  created_at: timestamptz
  date: daterange!

  """An object relationship"""
  details: availabilities_view

  """
  A computed field, executes function "boat.end_date"
  """
  end_date: date
  exclusion(
    """JSON select path"""
    path: String
  ): jsonb
  id: String!
  juggle: Boolean!
  pax: numrange!

  """An array relationship"""
  resources(
    """distinct select on columns"""
    distinct_on: [resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resources_order_by!]

    """filter the rows returned"""
    where: resources_bool_exp
  ): [resources!]!

  """An aggregated array relationship"""
  resources_aggregate(
    """distinct select on columns"""
    distinct_on: [resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resources_order_by!]

    """filter the rows returned"""
    where: resources_bool_exp
  ): resources_aggregate!

  """An array relationship"""
  sessions(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): [sessions!]!

  """An aggregated array relationship"""
  sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): sessions_aggregate!

  """
  A computed field, executes function "boat.start_date"
  """
  start_date: date
  updated_at: timestamptz
}

"""
aggregated selection of "boat.availabilities"
"""
type availabilities_aggregate {
  aggregate: availabilities_aggregate_fields
  nodes: [availabilities!]!
}

"""
aggregate fields of "boat.availabilities"
"""
type availabilities_aggregate_fields {
  count(columns: [availabilities_select_column!], distinct: Boolean): Int
  max: availabilities_max_fields
  min: availabilities_min_fields
}

"""
order by aggregate values of table "boat.availabilities"
"""
input availabilities_aggregate_order_by {
  count: order_by
  max: availabilities_max_order_by
  min: availabilities_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input availabilities_append_input {
  exclusion: jsonb
}

"""
input type for inserting array relation for remote table "boat.availabilities"
"""
input availabilities_arr_rel_insert_input {
  data: [availabilities_insert_input!]!
  on_conflict: availabilities_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.availabilities". All fields are combined with a logical 'AND'.
"""
input availabilities_bool_exp {
  _and: [availabilities_bool_exp]
  _not: availabilities_bool_exp
  _or: [availabilities_bool_exp]
  availabilities_group: availabilities_group_bool_exp
  availabilities_group_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  date: daterange_comparison_exp
  details: availabilities_view_bool_exp
  exclusion: jsonb_comparison_exp
  id: String_comparison_exp
  juggle: Boolean_comparison_exp
  pax: numrange_comparison_exp
  resources: resources_bool_exp
  sessions: sessions_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "boat.availabilities"
"""
enum availabilities_constraint {
  """unique or primary key constraint"""
  availabilities_id_key

  """unique or primary key constraint"""
  availabilities_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input availabilities_delete_at_path_input {
  exclusion: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input availabilities_delete_elem_input {
  exclusion: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input availabilities_delete_key_input {
  exclusion: String
}

"""
columns and relationships of "boat.availabilities_group"
"""
type availabilities_group {
  """An array relationship"""
  availabilities(
    """distinct select on columns"""
    distinct_on: [availabilities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_order_by!]

    """filter the rows returned"""
    where: availabilities_bool_exp
  ): [availabilities!]!

  """An aggregated array relationship"""
  availabilities_aggregate(
    """distinct select on columns"""
    distinct_on: [availabilities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_order_by!]

    """filter the rows returned"""
    where: availabilities_bool_exp
  ): availabilities_aggregate!

  """An object relationship"""
  city: city!
  city_id: String!
  created_at: timestamptz
  id: String!
  name: String!

  """An object relationship"""
  option: options
  option_id: String
  updated_at: timestamptz
}

"""
aggregated selection of "boat.availabilities_group"
"""
type availabilities_group_aggregate {
  aggregate: availabilities_group_aggregate_fields
  nodes: [availabilities_group!]!
}

"""
aggregate fields of "boat.availabilities_group"
"""
type availabilities_group_aggregate_fields {
  count(columns: [availabilities_group_select_column!], distinct: Boolean): Int
  max: availabilities_group_max_fields
  min: availabilities_group_min_fields
}

"""
order by aggregate values of table "boat.availabilities_group"
"""
input availabilities_group_aggregate_order_by {
  count: order_by
  max: availabilities_group_max_order_by
  min: availabilities_group_min_order_by
}

"""
input type for inserting array relation for remote table "boat.availabilities_group"
"""
input availabilities_group_arr_rel_insert_input {
  data: [availabilities_group_insert_input!]!
  on_conflict: availabilities_group_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.availabilities_group". All fields are combined with a logical 'AND'.
"""
input availabilities_group_bool_exp {
  _and: [availabilities_group_bool_exp]
  _not: availabilities_group_bool_exp
  _or: [availabilities_group_bool_exp]
  availabilities: availabilities_bool_exp
  city: city_bool_exp
  city_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  option: options_bool_exp
  option_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "boat.availabilities_group"
"""
enum availabilities_group_constraint {
  """unique or primary key constraint"""
  availabilities_group_pkey
}

"""
input type for inserting data into table "boat.availabilities_group"
"""
input availabilities_group_insert_input {
  availabilities: availabilities_arr_rel_insert_input
  city: city_obj_rel_insert_input
  city_id: String
  created_at: timestamptz
  id: String
  name: String
  option: options_obj_rel_insert_input
  option_id: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type availabilities_group_max_fields {
  city_id: String
  created_at: timestamptz
  id: String
  name: String
  option_id: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "boat.availabilities_group"
"""
input availabilities_group_max_order_by {
  city_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  option_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type availabilities_group_min_fields {
  city_id: String
  created_at: timestamptz
  id: String
  name: String
  option_id: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "boat.availabilities_group"
"""
input availabilities_group_min_order_by {
  city_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  option_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "boat.availabilities_group"
"""
type availabilities_group_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [availabilities_group!]!
}

"""
input type for inserting object relation for remote table "boat.availabilities_group"
"""
input availabilities_group_obj_rel_insert_input {
  data: availabilities_group_insert_input!
  on_conflict: availabilities_group_on_conflict
}

"""
on conflict condition type for table "boat.availabilities_group"
"""
input availabilities_group_on_conflict {
  constraint: availabilities_group_constraint!
  update_columns: [availabilities_group_update_column!]!
  where: availabilities_group_bool_exp
}

"""
ordering options when selecting data from "boat.availabilities_group"
"""
input availabilities_group_order_by {
  availabilities_aggregate: availabilities_aggregate_order_by
  city: city_order_by
  city_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  option: options_order_by
  option_id: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "boat.availabilities_group"
"""
input availabilities_group_pk_columns_input {
  id: String!
}

"""
select columns of table "boat.availabilities_group"
"""
enum availabilities_group_select_column {
  """column name"""
  city_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  option_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "boat.availabilities_group"
"""
input availabilities_group_set_input {
  city_id: String
  created_at: timestamptz
  id: String
  name: String
  option_id: String
  updated_at: timestamptz
}

"""
update columns of table "boat.availabilities_group"
"""
enum availabilities_group_update_column {
  """column name"""
  city_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  option_id

  """column name"""
  updated_at
}

"""
input type for inserting data into table "boat.availabilities"
"""
input availabilities_insert_input {
  availabilities_group: availabilities_group_obj_rel_insert_input
  availabilities_group_id: String
  created_at: timestamptz
  date: daterange
  exclusion: jsonb
  id: String
  juggle: Boolean
  pax: numrange
  resources: resources_arr_rel_insert_input
  sessions: sessions_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type availabilities_max_fields {
  availabilities_group_id: String
  created_at: timestamptz
  id: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "boat.availabilities"
"""
input availabilities_max_order_by {
  availabilities_group_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type availabilities_min_fields {
  availabilities_group_id: String
  created_at: timestamptz
  id: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "boat.availabilities"
"""
input availabilities_min_order_by {
  availabilities_group_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "boat.availabilities"
"""
type availabilities_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [availabilities!]!
}

"""
input type for inserting object relation for remote table "boat.availabilities"
"""
input availabilities_obj_rel_insert_input {
  data: availabilities_insert_input!
  on_conflict: availabilities_on_conflict
}

"""
on conflict condition type for table "boat.availabilities"
"""
input availabilities_on_conflict {
  constraint: availabilities_constraint!
  update_columns: [availabilities_update_column!]!
  where: availabilities_bool_exp
}

"""
ordering options when selecting data from "boat.availabilities"
"""
input availabilities_order_by {
  availabilities_group: availabilities_group_order_by
  availabilities_group_id: order_by
  created_at: order_by
  date: order_by
  details: availabilities_view_order_by
  exclusion: order_by
  id: order_by
  juggle: order_by
  pax: order_by
  resources_aggregate: resources_aggregate_order_by
  sessions_aggregate: sessions_aggregate_order_by
  updated_at: order_by
}

"""
primary key columns input for table: "boat.availabilities"
"""
input availabilities_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input availabilities_prepend_input {
  exclusion: jsonb
}

"""
select columns of table "boat.availabilities"
"""
enum availabilities_select_column {
  """column name"""
  availabilities_group_id

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  exclusion

  """column name"""
  id

  """column name"""
  juggle

  """column name"""
  pax

  """column name"""
  updated_at
}

"""
input type for updating data in table "boat.availabilities"
"""
input availabilities_set_input {
  availabilities_group_id: String
  created_at: timestamptz
  date: daterange
  exclusion: jsonb
  id: String
  juggle: Boolean
  pax: numrange
  updated_at: timestamptz
}

"""
update columns of table "boat.availabilities"
"""
enum availabilities_update_column {
  """column name"""
  availabilities_group_id

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  exclusion

  """column name"""
  id

  """column name"""
  juggle

  """column name"""
  pax

  """column name"""
  updated_at
}

"""
columns and relationships of "boat.availabilities_view"
"""
type availabilities_view {
  date_range: _date
  end_date: date
  id: String

  """An object relationship"""
  main: availabilities
  start_date: date
  total_resources: bigint
}

"""
aggregated selection of "boat.availabilities_view"
"""
type availabilities_view_aggregate {
  aggregate: availabilities_view_aggregate_fields
  nodes: [availabilities_view!]!
}

"""
aggregate fields of "boat.availabilities_view"
"""
type availabilities_view_aggregate_fields {
  avg: availabilities_view_avg_fields
  count(columns: [availabilities_view_select_column!], distinct: Boolean): Int
  max: availabilities_view_max_fields
  min: availabilities_view_min_fields
  stddev: availabilities_view_stddev_fields
  stddev_pop: availabilities_view_stddev_pop_fields
  stddev_samp: availabilities_view_stddev_samp_fields
  sum: availabilities_view_sum_fields
  var_pop: availabilities_view_var_pop_fields
  var_samp: availabilities_view_var_samp_fields
  variance: availabilities_view_variance_fields
}

"""
order by aggregate values of table "boat.availabilities_view"
"""
input availabilities_view_aggregate_order_by {
  avg: availabilities_view_avg_order_by
  count: order_by
  max: availabilities_view_max_order_by
  min: availabilities_view_min_order_by
  stddev: availabilities_view_stddev_order_by
  stddev_pop: availabilities_view_stddev_pop_order_by
  stddev_samp: availabilities_view_stddev_samp_order_by
  sum: availabilities_view_sum_order_by
  var_pop: availabilities_view_var_pop_order_by
  var_samp: availabilities_view_var_samp_order_by
  variance: availabilities_view_variance_order_by
}

"""aggregate avg on columns"""
type availabilities_view_avg_fields {
  total_resources: Float
}

"""
order by avg() on columns of table "boat.availabilities_view"
"""
input availabilities_view_avg_order_by {
  total_resources: order_by
}

"""
Boolean expression to filter rows from the table "boat.availabilities_view". All fields are combined with a logical 'AND'.
"""
input availabilities_view_bool_exp {
  _and: [availabilities_view_bool_exp]
  _not: availabilities_view_bool_exp
  _or: [availabilities_view_bool_exp]
  date_range: _date_comparison_exp
  end_date: date_comparison_exp
  id: String_comparison_exp
  main: availabilities_bool_exp
  start_date: date_comparison_exp
  total_resources: bigint_comparison_exp
}

"""aggregate max on columns"""
type availabilities_view_max_fields {
  end_date: date
  id: String
  start_date: date
  total_resources: bigint
}

"""
order by max() on columns of table "boat.availabilities_view"
"""
input availabilities_view_max_order_by {
  end_date: order_by
  id: order_by
  start_date: order_by
  total_resources: order_by
}

"""aggregate min on columns"""
type availabilities_view_min_fields {
  end_date: date
  id: String
  start_date: date
  total_resources: bigint
}

"""
order by min() on columns of table "boat.availabilities_view"
"""
input availabilities_view_min_order_by {
  end_date: order_by
  id: order_by
  start_date: order_by
  total_resources: order_by
}

"""
ordering options when selecting data from "boat.availabilities_view"
"""
input availabilities_view_order_by {
  date_range: order_by
  end_date: order_by
  id: order_by
  main: availabilities_order_by
  start_date: order_by
  total_resources: order_by
}

"""
select columns of table "boat.availabilities_view"
"""
enum availabilities_view_select_column {
  """column name"""
  date_range

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  start_date

  """column name"""
  total_resources
}

"""aggregate stddev on columns"""
type availabilities_view_stddev_fields {
  total_resources: Float
}

"""
order by stddev() on columns of table "boat.availabilities_view"
"""
input availabilities_view_stddev_order_by {
  total_resources: order_by
}

"""aggregate stddev_pop on columns"""
type availabilities_view_stddev_pop_fields {
  total_resources: Float
}

"""
order by stddev_pop() on columns of table "boat.availabilities_view"
"""
input availabilities_view_stddev_pop_order_by {
  total_resources: order_by
}

"""aggregate stddev_samp on columns"""
type availabilities_view_stddev_samp_fields {
  total_resources: Float
}

"""
order by stddev_samp() on columns of table "boat.availabilities_view"
"""
input availabilities_view_stddev_samp_order_by {
  total_resources: order_by
}

"""aggregate sum on columns"""
type availabilities_view_sum_fields {
  total_resources: bigint
}

"""
order by sum() on columns of table "boat.availabilities_view"
"""
input availabilities_view_sum_order_by {
  total_resources: order_by
}

"""aggregate var_pop on columns"""
type availabilities_view_var_pop_fields {
  total_resources: Float
}

"""
order by var_pop() on columns of table "boat.availabilities_view"
"""
input availabilities_view_var_pop_order_by {
  total_resources: order_by
}

"""aggregate var_samp on columns"""
type availabilities_view_var_samp_fields {
  total_resources: Float
}

"""
order by var_samp() on columns of table "boat.availabilities_view"
"""
input availabilities_view_var_samp_order_by {
  total_resources: order_by
}

"""aggregate variance on columns"""
type availabilities_view_variance_fields {
  total_resources: Float
}

"""
order by variance() on columns of table "boat.availabilities_view"
"""
input availabilities_view_variance_order_by {
  total_resources: order_by
}

"""
columns and relationships of "boat.booking"
"""
type booking {
  """An array relationship"""
  Logs(
    """distinct select on columns"""
    distinct_on: [logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [logs_order_by!]

    """filter the rows returned"""
    where: logs_bool_exp
  ): [logs!]!

  """An aggregated array relationship"""
  Logs_aggregate(
    """distinct select on columns"""
    distinct_on: [logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [logs_order_by!]

    """filter the rows returned"""
    where: logs_bool_exp
  ): logs_aggregate!
  adults: Int!
  airtable_id: String
  assigned_guide: String
  assigned_vehicle: String
  channel_id: String
  children: Int!
  confirmation_id: String
  created_at: timestamptz!

  """An object relationship"""
  customer: customers!
  customer_id: String!
  id: String!
  infants: Int!

  """An array relationship"""
  message_correspondence(
    """distinct select on columns"""
    distinct_on: [message_correspondence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_correspondence_order_by!]

    """filter the rows returned"""
    where: message_correspondence_bool_exp
  ): [message_correspondence!]!

  """An aggregated array relationship"""
  message_correspondence_aggregate(
    """distinct select on columns"""
    distinct_on: [message_correspondence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_correspondence_order_by!]

    """filter the rows returned"""
    where: message_correspondence_bool_exp
  ): message_correspondence_aggregate!
  notes(
    """JSON select path"""
    path: String
  ): jsonb

  """
  A computed field, executes function "boat.booking_pax"
  """
  pax: bigint
  pickup_location: String
  pickup_time: String
  region: String
  status: String

  """An array relationship"""
  subtasks(
    """distinct select on columns"""
    distinct_on: [subtasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subtasks_order_by!]

    """filter the rows returned"""
    where: subtasks_bool_exp
  ): [subtasks!]!

  """An aggregated array relationship"""
  subtasks_aggregate(
    """distinct select on columns"""
    distinct_on: [subtasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subtasks_order_by!]

    """filter the rows returned"""
    where: subtasks_bool_exp
  ): subtasks_aggregate!
  tour_date: timestamptz!
  tour_name: String!

  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): [transactions!]!

  """An aggregated array relationship"""
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): transactions_aggregate!
  updated_at: timestamptz!
}

"""
aggregated selection of "boat.booking"
"""
type booking_aggregate {
  aggregate: booking_aggregate_fields
  nodes: [booking!]!
}

"""
aggregate fields of "boat.booking"
"""
type booking_aggregate_fields {
  avg: booking_avg_fields
  count(columns: [booking_select_column!], distinct: Boolean): Int
  max: booking_max_fields
  min: booking_min_fields
  stddev: booking_stddev_fields
  stddev_pop: booking_stddev_pop_fields
  stddev_samp: booking_stddev_samp_fields
  sum: booking_sum_fields
  var_pop: booking_var_pop_fields
  var_samp: booking_var_samp_fields
  variance: booking_variance_fields
}

"""
order by aggregate values of table "boat.booking"
"""
input booking_aggregate_order_by {
  avg: booking_avg_order_by
  count: order_by
  max: booking_max_order_by
  min: booking_min_order_by
  stddev: booking_stddev_order_by
  stddev_pop: booking_stddev_pop_order_by
  stddev_samp: booking_stddev_samp_order_by
  sum: booking_sum_order_by
  var_pop: booking_var_pop_order_by
  var_samp: booking_var_samp_order_by
  variance: booking_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input booking_append_input {
  notes: jsonb
}

"""
input type for inserting array relation for remote table "boat.booking"
"""
input booking_arr_rel_insert_input {
  data: [booking_insert_input!]!
  on_conflict: booking_on_conflict
}

"""aggregate avg on columns"""
type booking_avg_fields {
  adults: Float
  children: Float
  infants: Float
}

"""
order by avg() on columns of table "boat.booking"
"""
input booking_avg_order_by {
  adults: order_by
  children: order_by
  infants: order_by
}

"""
Boolean expression to filter rows from the table "boat.booking". All fields are combined with a logical 'AND'.
"""
input booking_bool_exp {
  Logs: logs_bool_exp
  _and: [booking_bool_exp]
  _not: booking_bool_exp
  _or: [booking_bool_exp]
  adults: Int_comparison_exp
  airtable_id: String_comparison_exp
  assigned_guide: String_comparison_exp
  assigned_vehicle: String_comparison_exp
  channel_id: String_comparison_exp
  children: Int_comparison_exp
  confirmation_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  customer: customers_bool_exp
  customer_id: String_comparison_exp
  id: String_comparison_exp
  infants: Int_comparison_exp
  message_correspondence: message_correspondence_bool_exp
  notes: jsonb_comparison_exp
  pickup_location: String_comparison_exp
  pickup_time: String_comparison_exp
  region: String_comparison_exp
  status: String_comparison_exp
  subtasks: subtasks_bool_exp
  tour_date: timestamptz_comparison_exp
  tour_name: String_comparison_exp
  transactions: transactions_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "boat.booking"
"""
enum booking_constraint {
  """unique or primary key constraint"""
  booking_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input booking_delete_at_path_input {
  notes: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input booking_delete_elem_input {
  notes: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input booking_delete_key_input {
  notes: String
}

"""
input type for incrementing integer column in table "boat.booking"
"""
input booking_inc_input {
  adults: Int
  children: Int
  infants: Int
}

"""
input type for inserting data into table "boat.booking"
"""
input booking_insert_input {
  Logs: logs_arr_rel_insert_input
  adults: Int
  airtable_id: String
  assigned_guide: String
  assigned_vehicle: String
  channel_id: String
  children: Int
  confirmation_id: String
  created_at: timestamptz
  customer: customers_obj_rel_insert_input
  customer_id: String
  id: String
  infants: Int
  message_correspondence: message_correspondence_arr_rel_insert_input
  notes: jsonb
  pickup_location: String
  pickup_time: String
  region: String
  status: String
  subtasks: subtasks_arr_rel_insert_input
  tour_date: timestamptz
  tour_name: String
  transactions: transactions_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type booking_max_fields {
  adults: Int
  airtable_id: String
  assigned_guide: String
  assigned_vehicle: String
  channel_id: String
  children: Int
  confirmation_id: String
  created_at: timestamptz
  customer_id: String
  id: String
  infants: Int
  pickup_location: String
  pickup_time: String
  region: String
  status: String
  tour_date: timestamptz
  tour_name: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "boat.booking"
"""
input booking_max_order_by {
  adults: order_by
  airtable_id: order_by
  assigned_guide: order_by
  assigned_vehicle: order_by
  channel_id: order_by
  children: order_by
  confirmation_id: order_by
  created_at: order_by
  customer_id: order_by
  id: order_by
  infants: order_by
  pickup_location: order_by
  pickup_time: order_by
  region: order_by
  status: order_by
  tour_date: order_by
  tour_name: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type booking_min_fields {
  adults: Int
  airtable_id: String
  assigned_guide: String
  assigned_vehicle: String
  channel_id: String
  children: Int
  confirmation_id: String
  created_at: timestamptz
  customer_id: String
  id: String
  infants: Int
  pickup_location: String
  pickup_time: String
  region: String
  status: String
  tour_date: timestamptz
  tour_name: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "boat.booking"
"""
input booking_min_order_by {
  adults: order_by
  airtable_id: order_by
  assigned_guide: order_by
  assigned_vehicle: order_by
  channel_id: order_by
  children: order_by
  confirmation_id: order_by
  created_at: order_by
  customer_id: order_by
  id: order_by
  infants: order_by
  pickup_location: order_by
  pickup_time: order_by
  region: order_by
  status: order_by
  tour_date: order_by
  tour_name: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "boat.booking"
"""
type booking_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [booking!]!
}

"""
input type for inserting object relation for remote table "boat.booking"
"""
input booking_obj_rel_insert_input {
  data: booking_insert_input!
  on_conflict: booking_on_conflict
}

"""
on conflict condition type for table "boat.booking"
"""
input booking_on_conflict {
  constraint: booking_constraint!
  update_columns: [booking_update_column!]!
  where: booking_bool_exp
}

"""
ordering options when selecting data from "boat.booking"
"""
input booking_order_by {
  Logs_aggregate: logs_aggregate_order_by
  adults: order_by
  airtable_id: order_by
  assigned_guide: order_by
  assigned_vehicle: order_by
  channel_id: order_by
  children: order_by
  confirmation_id: order_by
  created_at: order_by
  customer: customers_order_by
  customer_id: order_by
  id: order_by
  infants: order_by
  message_correspondence_aggregate: message_correspondence_aggregate_order_by
  notes: order_by
  pickup_location: order_by
  pickup_time: order_by
  region: order_by
  status: order_by
  subtasks_aggregate: subtasks_aggregate_order_by
  tour_date: order_by
  tour_name: order_by
  transactions_aggregate: transactions_aggregate_order_by
  updated_at: order_by
}

"""
primary key columns input for table: "boat.booking"
"""
input booking_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input booking_prepend_input {
  notes: jsonb
}

"""
select columns of table "boat.booking"
"""
enum booking_select_column {
  """column name"""
  adults

  """column name"""
  airtable_id

  """column name"""
  assigned_guide

  """column name"""
  assigned_vehicle

  """column name"""
  channel_id

  """column name"""
  children

  """column name"""
  confirmation_id

  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  infants

  """column name"""
  notes

  """column name"""
  pickup_location

  """column name"""
  pickup_time

  """column name"""
  region

  """column name"""
  status

  """column name"""
  tour_date

  """column name"""
  tour_name

  """column name"""
  updated_at
}

"""
input type for updating data in table "boat.booking"
"""
input booking_set_input {
  adults: Int
  airtable_id: String
  assigned_guide: String
  assigned_vehicle: String
  channel_id: String
  children: Int
  confirmation_id: String
  created_at: timestamptz
  customer_id: String
  id: String
  infants: Int
  notes: jsonb
  pickup_location: String
  pickup_time: String
  region: String
  status: String
  tour_date: timestamptz
  tour_name: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type booking_stddev_fields {
  adults: Float
  children: Float
  infants: Float
}

"""
order by stddev() on columns of table "boat.booking"
"""
input booking_stddev_order_by {
  adults: order_by
  children: order_by
  infants: order_by
}

"""aggregate stddev_pop on columns"""
type booking_stddev_pop_fields {
  adults: Float
  children: Float
  infants: Float
}

"""
order by stddev_pop() on columns of table "boat.booking"
"""
input booking_stddev_pop_order_by {
  adults: order_by
  children: order_by
  infants: order_by
}

"""aggregate stddev_samp on columns"""
type booking_stddev_samp_fields {
  adults: Float
  children: Float
  infants: Float
}

"""
order by stddev_samp() on columns of table "boat.booking"
"""
input booking_stddev_samp_order_by {
  adults: order_by
  children: order_by
  infants: order_by
}

"""aggregate sum on columns"""
type booking_sum_fields {
  adults: Int
  children: Int
  infants: Int
}

"""
order by sum() on columns of table "boat.booking"
"""
input booking_sum_order_by {
  adults: order_by
  children: order_by
  infants: order_by
}

"""
update columns of table "boat.booking"
"""
enum booking_update_column {
  """column name"""
  adults

  """column name"""
  airtable_id

  """column name"""
  assigned_guide

  """column name"""
  assigned_vehicle

  """column name"""
  channel_id

  """column name"""
  children

  """column name"""
  confirmation_id

  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  id

  """column name"""
  infants

  """column name"""
  notes

  """column name"""
  pickup_location

  """column name"""
  pickup_time

  """column name"""
  region

  """column name"""
  status

  """column name"""
  tour_date

  """column name"""
  tour_name

  """column name"""
  updated_at
}

"""aggregate var_pop on columns"""
type booking_var_pop_fields {
  adults: Float
  children: Float
  infants: Float
}

"""
order by var_pop() on columns of table "boat.booking"
"""
input booking_var_pop_order_by {
  adults: order_by
  children: order_by
  infants: order_by
}

"""aggregate var_samp on columns"""
type booking_var_samp_fields {
  adults: Float
  children: Float
  infants: Float
}

"""
order by var_samp() on columns of table "boat.booking"
"""
input booking_var_samp_order_by {
  adults: order_by
  children: order_by
  infants: order_by
}

"""aggregate variance on columns"""
type booking_variance_fields {
  adults: Float
  children: Float
  infants: Float
}

"""
order by variance() on columns of table "boat.booking"
"""
input booking_variance_order_by {
  adults: order_by
  children: order_by
  infants: order_by
}

"""
columns and relationships of "boat.city"
"""
type city {
  """An array relationship"""
  attractions(
    """distinct select on columns"""
    distinct_on: [attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attractions_order_by!]

    """filter the rows returned"""
    where: attractions_bool_exp
  ): [attractions!]!

  """An aggregated array relationship"""
  attractions_aggregate(
    """distinct select on columns"""
    distinct_on: [attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attractions_order_by!]

    """filter the rows returned"""
    where: attractions_bool_exp
  ): attractions_aggregate!

  """An array relationship"""
  availabilities_groups(
    """distinct select on columns"""
    distinct_on: [availabilities_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_group_order_by!]

    """filter the rows returned"""
    where: availabilities_group_bool_exp
  ): [availabilities_group!]!

  """An aggregated array relationship"""
  availabilities_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [availabilities_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_group_order_by!]

    """filter the rows returned"""
    where: availabilities_group_bool_exp
  ): availabilities_group_aggregate!
  coordinates(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamptz
  id: String!
  locale: String
  name: String!

  """An array relationship"""
  products(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """An aggregated array relationship"""
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): products_aggregate!
  time_zone: String
  updated_at: timestamptz

  """An array relationship"""
  vehicles(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!

  """An aggregated array relationship"""
  vehicles_aggregate(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): vehicles_aggregate!
}

"""
aggregated selection of "boat.city"
"""
type city_aggregate {
  aggregate: city_aggregate_fields
  nodes: [city!]!
}

"""
aggregate fields of "boat.city"
"""
type city_aggregate_fields {
  count(columns: [city_select_column!], distinct: Boolean): Int
  max: city_max_fields
  min: city_min_fields
}

"""
order by aggregate values of table "boat.city"
"""
input city_aggregate_order_by {
  count: order_by
  max: city_max_order_by
  min: city_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input city_append_input {
  coordinates: jsonb
}

"""
input type for inserting array relation for remote table "boat.city"
"""
input city_arr_rel_insert_input {
  data: [city_insert_input!]!
  on_conflict: city_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.city". All fields are combined with a logical 'AND'.
"""
input city_bool_exp {
  _and: [city_bool_exp]
  _not: city_bool_exp
  _or: [city_bool_exp]
  attractions: attractions_bool_exp
  availabilities_groups: availabilities_group_bool_exp
  coordinates: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  locale: String_comparison_exp
  name: String_comparison_exp
  products: products_bool_exp
  time_zone: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  vehicles: vehicles_bool_exp
}

"""
unique or primary key constraints on table "boat.city"
"""
enum city_constraint {
  """unique or primary key constraint"""
  city_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input city_delete_at_path_input {
  coordinates: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input city_delete_elem_input {
  coordinates: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input city_delete_key_input {
  coordinates: String
}

"""
input type for inserting data into table "boat.city"
"""
input city_insert_input {
  attractions: attractions_arr_rel_insert_input
  availabilities_groups: availabilities_group_arr_rel_insert_input
  coordinates: jsonb
  created_at: timestamptz
  id: String
  locale: String
  name: String
  products: products_arr_rel_insert_input
  time_zone: String
  updated_at: timestamptz
  vehicles: vehicles_arr_rel_insert_input
}

"""aggregate max on columns"""
type city_max_fields {
  created_at: timestamptz
  id: String
  locale: String
  name: String
  time_zone: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "boat.city"
"""
input city_max_order_by {
  created_at: order_by
  id: order_by
  locale: order_by
  name: order_by
  time_zone: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type city_min_fields {
  created_at: timestamptz
  id: String
  locale: String
  name: String
  time_zone: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "boat.city"
"""
input city_min_order_by {
  created_at: order_by
  id: order_by
  locale: order_by
  name: order_by
  time_zone: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "boat.city"
"""
type city_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [city!]!
}

"""
input type for inserting object relation for remote table "boat.city"
"""
input city_obj_rel_insert_input {
  data: city_insert_input!
  on_conflict: city_on_conflict
}

"""
on conflict condition type for table "boat.city"
"""
input city_on_conflict {
  constraint: city_constraint!
  update_columns: [city_update_column!]!
  where: city_bool_exp
}

"""
ordering options when selecting data from "boat.city"
"""
input city_order_by {
  attractions_aggregate: attractions_aggregate_order_by
  availabilities_groups_aggregate: availabilities_group_aggregate_order_by
  coordinates: order_by
  created_at: order_by
  id: order_by
  locale: order_by
  name: order_by
  products_aggregate: products_aggregate_order_by
  time_zone: order_by
  updated_at: order_by
  vehicles_aggregate: vehicles_aggregate_order_by
}

"""
primary key columns input for table: "boat.city"
"""
input city_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input city_prepend_input {
  coordinates: jsonb
}

"""
select columns of table "boat.city"
"""
enum city_select_column {
  """column name"""
  coordinates

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  time_zone

  """column name"""
  updated_at
}

"""
input type for updating data in table "boat.city"
"""
input city_set_input {
  coordinates: jsonb
  created_at: timestamptz
  id: String
  locale: String
  name: String
  time_zone: String
  updated_at: timestamptz
}

"""
update columns of table "boat.city"
"""
enum city_update_column {
  """column name"""
  coordinates

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  time_zone

  """column name"""
  updated_at
}

"""
columns and relationships of "boat.customers"
"""
type customers {
  """An array relationship"""
  bookings(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """An aggregated array relationship"""
  bookings_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!
  created_at: timestamptz
  email: String!
  first_name: String!
  id: String!
  last_name: String!
  phone: String!
  secondary_email: String
  secondary_phone: String

  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): [transactions!]!

  """An aggregated array relationship"""
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): transactions_aggregate!
  updated_at: timestamptz
}

"""
aggregated selection of "boat.customers"
"""
type customers_aggregate {
  aggregate: customers_aggregate_fields
  nodes: [customers!]!
}

"""
aggregate fields of "boat.customers"
"""
type customers_aggregate_fields {
  count(columns: [customers_select_column!], distinct: Boolean): Int
  max: customers_max_fields
  min: customers_min_fields
}

"""
order by aggregate values of table "boat.customers"
"""
input customers_aggregate_order_by {
  count: order_by
  max: customers_max_order_by
  min: customers_min_order_by
}

"""
input type for inserting array relation for remote table "boat.customers"
"""
input customers_arr_rel_insert_input {
  data: [customers_insert_input!]!
  on_conflict: customers_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.customers". All fields are combined with a logical 'AND'.
"""
input customers_bool_exp {
  _and: [customers_bool_exp]
  _not: customers_bool_exp
  _or: [customers_bool_exp]
  bookings: booking_bool_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  first_name: String_comparison_exp
  id: String_comparison_exp
  last_name: String_comparison_exp
  phone: String_comparison_exp
  secondary_email: String_comparison_exp
  secondary_phone: String_comparison_exp
  transactions: transactions_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "boat.customers"
"""
enum customers_constraint {
  """unique or primary key constraint"""
  customers_pkey
}

"""
input type for inserting data into table "boat.customers"
"""
input customers_insert_input {
  bookings: booking_arr_rel_insert_input
  created_at: timestamptz
  email: String
  first_name: String
  id: String
  last_name: String
  phone: String
  secondary_email: String
  secondary_phone: String
  transactions: transactions_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type customers_max_fields {
  created_at: timestamptz
  email: String
  first_name: String
  id: String
  last_name: String
  phone: String
  secondary_email: String
  secondary_phone: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "boat.customers"
"""
input customers_max_order_by {
  created_at: order_by
  email: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  phone: order_by
  secondary_email: order_by
  secondary_phone: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type customers_min_fields {
  created_at: timestamptz
  email: String
  first_name: String
  id: String
  last_name: String
  phone: String
  secondary_email: String
  secondary_phone: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "boat.customers"
"""
input customers_min_order_by {
  created_at: order_by
  email: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  phone: order_by
  secondary_email: order_by
  secondary_phone: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "boat.customers"
"""
type customers_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [customers!]!
}

"""
input type for inserting object relation for remote table "boat.customers"
"""
input customers_obj_rel_insert_input {
  data: customers_insert_input!
  on_conflict: customers_on_conflict
}

"""
on conflict condition type for table "boat.customers"
"""
input customers_on_conflict {
  constraint: customers_constraint!
  update_columns: [customers_update_column!]!
  where: customers_bool_exp
}

"""
ordering options when selecting data from "boat.customers"
"""
input customers_order_by {
  bookings_aggregate: booking_aggregate_order_by
  created_at: order_by
  email: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
  phone: order_by
  secondary_email: order_by
  secondary_phone: order_by
  transactions_aggregate: transactions_aggregate_order_by
  updated_at: order_by
}

"""
primary key columns input for table: "boat.customers"
"""
input customers_pk_columns_input {
  id: String!
}

"""
select columns of table "boat.customers"
"""
enum customers_select_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  last_name

  """column name"""
  phone

  """column name"""
  secondary_email

  """column name"""
  secondary_phone

  """column name"""
  updated_at
}

"""
input type for updating data in table "boat.customers"
"""
input customers_set_input {
  created_at: timestamptz
  email: String
  first_name: String
  id: String
  last_name: String
  phone: String
  secondary_email: String
  secondary_phone: String
  updated_at: timestamptz
}

"""
update columns of table "boat.customers"
"""
enum customers_update_column {
  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  last_name

  """column name"""
  phone

  """column name"""
  secondary_email

  """column name"""
  secondary_phone

  """column name"""
  updated_at
}

"""
columns and relationships of "boat.logs"
"""
type logs {
  action: String

  """An object relationship"""
  booking: booking
  booking_id: String
  created_at: timestamptz!
  date: date
  id: String!
  updated_at: timestamptz!
  user: String
}

"""
aggregated selection of "boat.logs"
"""
type logs_aggregate {
  aggregate: logs_aggregate_fields
  nodes: [logs!]!
}

"""
aggregate fields of "boat.logs"
"""
type logs_aggregate_fields {
  count(columns: [logs_select_column!], distinct: Boolean): Int
  max: logs_max_fields
  min: logs_min_fields
}

"""
order by aggregate values of table "boat.logs"
"""
input logs_aggregate_order_by {
  count: order_by
  max: logs_max_order_by
  min: logs_min_order_by
}

"""
input type for inserting array relation for remote table "boat.logs"
"""
input logs_arr_rel_insert_input {
  data: [logs_insert_input!]!
  on_conflict: logs_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.logs". All fields are combined with a logical 'AND'.
"""
input logs_bool_exp {
  _and: [logs_bool_exp]
  _not: logs_bool_exp
  _or: [logs_bool_exp]
  action: String_comparison_exp
  booking: booking_bool_exp
  booking_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  date: date_comparison_exp
  id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: String_comparison_exp
}

"""
unique or primary key constraints on table "boat.logs"
"""
enum logs_constraint {
  """unique or primary key constraint"""
  logs_pkey
}

"""
input type for inserting data into table "boat.logs"
"""
input logs_insert_input {
  action: String
  booking: booking_obj_rel_insert_input
  booking_id: String
  created_at: timestamptz
  date: date
  id: String
  updated_at: timestamptz
  user: String
}

"""aggregate max on columns"""
type logs_max_fields {
  action: String
  booking_id: String
  created_at: timestamptz
  date: date
  id: String
  updated_at: timestamptz
  user: String
}

"""
order by max() on columns of table "boat.logs"
"""
input logs_max_order_by {
  action: order_by
  booking_id: order_by
  created_at: order_by
  date: order_by
  id: order_by
  updated_at: order_by
  user: order_by
}

"""aggregate min on columns"""
type logs_min_fields {
  action: String
  booking_id: String
  created_at: timestamptz
  date: date
  id: String
  updated_at: timestamptz
  user: String
}

"""
order by min() on columns of table "boat.logs"
"""
input logs_min_order_by {
  action: order_by
  booking_id: order_by
  created_at: order_by
  date: order_by
  id: order_by
  updated_at: order_by
  user: order_by
}

"""
response of any mutation on the table "boat.logs"
"""
type logs_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [logs!]!
}

"""
input type for inserting object relation for remote table "boat.logs"
"""
input logs_obj_rel_insert_input {
  data: logs_insert_input!
  on_conflict: logs_on_conflict
}

"""
on conflict condition type for table "boat.logs"
"""
input logs_on_conflict {
  constraint: logs_constraint!
  update_columns: [logs_update_column!]!
  where: logs_bool_exp
}

"""
ordering options when selecting data from "boat.logs"
"""
input logs_order_by {
  action: order_by
  booking: booking_order_by
  booking_id: order_by
  created_at: order_by
  date: order_by
  id: order_by
  updated_at: order_by
  user: order_by
}

"""
primary key columns input for table: "boat.logs"
"""
input logs_pk_columns_input {
  id: String!
}

"""
select columns of table "boat.logs"
"""
enum logs_select_column {
  """column name"""
  action

  """column name"""
  booking_id

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  user
}

"""
input type for updating data in table "boat.logs"
"""
input logs_set_input {
  action: String
  booking_id: String
  created_at: timestamptz
  date: date
  id: String
  updated_at: timestamptz
  user: String
}

"""
update columns of table "boat.logs"
"""
enum logs_update_column {
  """column name"""
  action

  """column name"""
  booking_id

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  id

  """column name"""
  updated_at

  """column name"""
  user
}

"""
columns and relationships of "boat.message_correspondence"
"""
type message_correspondence {
  """An object relationship"""
  booking: booking
  booking_id: String
  contents: String
  created_at: timestamptz
  id: String!
  message_type: String
  recipient: String
  send_date: date
  sender: String!
  status: String
  subject: String
  updated_at: timestamptz
}

"""
aggregated selection of "boat.message_correspondence"
"""
type message_correspondence_aggregate {
  aggregate: message_correspondence_aggregate_fields
  nodes: [message_correspondence!]!
}

"""
aggregate fields of "boat.message_correspondence"
"""
type message_correspondence_aggregate_fields {
  count(columns: [message_correspondence_select_column!], distinct: Boolean): Int
  max: message_correspondence_max_fields
  min: message_correspondence_min_fields
}

"""
order by aggregate values of table "boat.message_correspondence"
"""
input message_correspondence_aggregate_order_by {
  count: order_by
  max: message_correspondence_max_order_by
  min: message_correspondence_min_order_by
}

"""
input type for inserting array relation for remote table "boat.message_correspondence"
"""
input message_correspondence_arr_rel_insert_input {
  data: [message_correspondence_insert_input!]!
  on_conflict: message_correspondence_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.message_correspondence". All fields are combined with a logical 'AND'.
"""
input message_correspondence_bool_exp {
  _and: [message_correspondence_bool_exp]
  _not: message_correspondence_bool_exp
  _or: [message_correspondence_bool_exp]
  booking: booking_bool_exp
  booking_id: String_comparison_exp
  contents: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  message_type: String_comparison_exp
  recipient: String_comparison_exp
  send_date: date_comparison_exp
  sender: String_comparison_exp
  status: String_comparison_exp
  subject: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "boat.message_correspondence"
"""
enum message_correspondence_constraint {
  """unique or primary key constraint"""
  message_correspondence_pkey
}

"""
input type for inserting data into table "boat.message_correspondence"
"""
input message_correspondence_insert_input {
  booking: booking_obj_rel_insert_input
  booking_id: String
  contents: String
  created_at: timestamptz
  id: String
  message_type: String
  recipient: String
  send_date: date
  sender: String
  status: String
  subject: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type message_correspondence_max_fields {
  booking_id: String
  contents: String
  created_at: timestamptz
  id: String
  message_type: String
  recipient: String
  send_date: date
  sender: String
  status: String
  subject: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "boat.message_correspondence"
"""
input message_correspondence_max_order_by {
  booking_id: order_by
  contents: order_by
  created_at: order_by
  id: order_by
  message_type: order_by
  recipient: order_by
  send_date: order_by
  sender: order_by
  status: order_by
  subject: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type message_correspondence_min_fields {
  booking_id: String
  contents: String
  created_at: timestamptz
  id: String
  message_type: String
  recipient: String
  send_date: date
  sender: String
  status: String
  subject: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "boat.message_correspondence"
"""
input message_correspondence_min_order_by {
  booking_id: order_by
  contents: order_by
  created_at: order_by
  id: order_by
  message_type: order_by
  recipient: order_by
  send_date: order_by
  sender: order_by
  status: order_by
  subject: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "boat.message_correspondence"
"""
type message_correspondence_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [message_correspondence!]!
}

"""
input type for inserting object relation for remote table "boat.message_correspondence"
"""
input message_correspondence_obj_rel_insert_input {
  data: message_correspondence_insert_input!
  on_conflict: message_correspondence_on_conflict
}

"""
on conflict condition type for table "boat.message_correspondence"
"""
input message_correspondence_on_conflict {
  constraint: message_correspondence_constraint!
  update_columns: [message_correspondence_update_column!]!
  where: message_correspondence_bool_exp
}

"""
ordering options when selecting data from "boat.message_correspondence"
"""
input message_correspondence_order_by {
  booking: booking_order_by
  booking_id: order_by
  contents: order_by
  created_at: order_by
  id: order_by
  message_type: order_by
  recipient: order_by
  send_date: order_by
  sender: order_by
  status: order_by
  subject: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "boat.message_correspondence"
"""
input message_correspondence_pk_columns_input {
  id: String!
}

"""
select columns of table "boat.message_correspondence"
"""
enum message_correspondence_select_column {
  """column name"""
  booking_id

  """column name"""
  contents

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  message_type

  """column name"""
  recipient

  """column name"""
  send_date

  """column name"""
  sender

  """column name"""
  status

  """column name"""
  subject

  """column name"""
  updated_at
}

"""
input type for updating data in table "boat.message_correspondence"
"""
input message_correspondence_set_input {
  booking_id: String
  contents: String
  created_at: timestamptz
  id: String
  message_type: String
  recipient: String
  send_date: date
  sender: String
  status: String
  subject: String
  updated_at: timestamptz
}

"""
update columns of table "boat.message_correspondence"
"""
enum message_correspondence_update_column {
  """column name"""
  booking_id

  """column name"""
  contents

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  message_type

  """column name"""
  recipient

  """column name"""
  send_date

  """column name"""
  sender

  """column name"""
  status

  """column name"""
  subject

  """column name"""
  updated_at
}

"""
columns and relationships of "boat.options"
"""
type options {
  """An array relationship"""
  availabilities_groups(
    """distinct select on columns"""
    distinct_on: [availabilities_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_group_order_by!]

    """filter the rows returned"""
    where: availabilities_group_bool_exp
  ): [availabilities_group!]!

  """An aggregated array relationship"""
  availabilities_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [availabilities_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_group_order_by!]

    """filter the rows returned"""
    where: availabilities_group_bool_exp
  ): availabilities_group_aggregate!
  created_at: timestamptz
  id: String!

  """An object relationship"""
  options_view: options_view

  """An object relationship"""
  product: products!
  product_id: String!
  reference: String
  start_time: time!
  updated_at: timestamptz
}

"""
aggregated selection of "boat.options"
"""
type options_aggregate {
  aggregate: options_aggregate_fields
  nodes: [options!]!
}

"""
aggregate fields of "boat.options"
"""
type options_aggregate_fields {
  count(columns: [options_select_column!], distinct: Boolean): Int
  max: options_max_fields
  min: options_min_fields
}

"""
order by aggregate values of table "boat.options"
"""
input options_aggregate_order_by {
  count: order_by
  max: options_max_order_by
  min: options_min_order_by
}

"""
input type for inserting array relation for remote table "boat.options"
"""
input options_arr_rel_insert_input {
  data: [options_insert_input!]!
  on_conflict: options_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.options". All fields are combined with a logical 'AND'.
"""
input options_bool_exp {
  _and: [options_bool_exp]
  _not: options_bool_exp
  _or: [options_bool_exp]
  availabilities_groups: availabilities_group_bool_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  options_view: options_view_bool_exp
  product: products_bool_exp
  product_id: String_comparison_exp
  reference: String_comparison_exp
  start_time: time_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "boat.options"
"""
enum options_constraint {
  """unique or primary key constraint"""
  options_pkey

  """unique or primary key constraint"""
  options_id_key
}

"""
input type for inserting data into table "boat.options"
"""
input options_insert_input {
  availabilities_groups: availabilities_group_arr_rel_insert_input
  created_at: timestamptz
  id: String
  product: products_obj_rel_insert_input
  product_id: String
  reference: String
  start_time: time
  updated_at: timestamptz
}

"""aggregate max on columns"""
type options_max_fields {
  created_at: timestamptz
  id: String
  product_id: String
  reference: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "boat.options"
"""
input options_max_order_by {
  created_at: order_by
  id: order_by
  product_id: order_by
  reference: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type options_min_fields {
  created_at: timestamptz
  id: String
  product_id: String
  reference: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "boat.options"
"""
input options_min_order_by {
  created_at: order_by
  id: order_by
  product_id: order_by
  reference: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "boat.options"
"""
type options_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [options!]!
}

"""
input type for inserting object relation for remote table "boat.options"
"""
input options_obj_rel_insert_input {
  data: options_insert_input!
  on_conflict: options_on_conflict
}

"""
on conflict condition type for table "boat.options"
"""
input options_on_conflict {
  constraint: options_constraint!
  update_columns: [options_update_column!]!
  where: options_bool_exp
}

"""
ordering options when selecting data from "boat.options"
"""
input options_order_by {
  availabilities_groups_aggregate: availabilities_group_aggregate_order_by
  created_at: order_by
  id: order_by
  options_view: options_view_order_by
  product: products_order_by
  product_id: order_by
  reference: order_by
  start_time: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "boat.options"
"""
input options_pk_columns_input {
  id: String!
}

"""
select columns of table "boat.options"
"""
enum options_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  reference

  """column name"""
  start_time

  """column name"""
  updated_at
}

"""
input type for updating data in table "boat.options"
"""
input options_set_input {
  created_at: timestamptz
  id: String
  product_id: String
  reference: String
  start_time: time
  updated_at: timestamptz
}

"""
update columns of table "boat.options"
"""
enum options_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  product_id

  """column name"""
  reference

  """column name"""
  start_time

  """column name"""
  updated_at
}

"""
columns and relationships of "boat.options_view"
"""
type options_view {
  end_time: time
  id: String

  """An object relationship"""
  options: options
}

"""
aggregated selection of "boat.options_view"
"""
type options_view_aggregate {
  aggregate: options_view_aggregate_fields
  nodes: [options_view!]!
}

"""
aggregate fields of "boat.options_view"
"""
type options_view_aggregate_fields {
  count(columns: [options_view_select_column!], distinct: Boolean): Int
  max: options_view_max_fields
  min: options_view_min_fields
}

"""
order by aggregate values of table "boat.options_view"
"""
input options_view_aggregate_order_by {
  count: order_by
  max: options_view_max_order_by
  min: options_view_min_order_by
}

"""
Boolean expression to filter rows from the table "boat.options_view". All fields are combined with a logical 'AND'.
"""
input options_view_bool_exp {
  _and: [options_view_bool_exp]
  _not: options_view_bool_exp
  _or: [options_view_bool_exp]
  end_time: time_comparison_exp
  id: String_comparison_exp
  options: options_bool_exp
}

"""aggregate max on columns"""
type options_view_max_fields {
  id: String
}

"""
order by max() on columns of table "boat.options_view"
"""
input options_view_max_order_by {
  id: order_by
}

"""aggregate min on columns"""
type options_view_min_fields {
  id: String
}

"""
order by min() on columns of table "boat.options_view"
"""
input options_view_min_order_by {
  id: order_by
}

"""
ordering options when selecting data from "boat.options_view"
"""
input options_view_order_by {
  end_time: order_by
  id: order_by
  options: options_order_by
}

"""
select columns of table "boat.options_view"
"""
enum options_view_select_column {
  """column name"""
  end_time

  """column name"""
  id
}

"""
columns and relationships of "boat.products"
"""
type products {
  active: Boolean!
  advertised_price: String

  """An array relationship"""
  channel_products(
    """distinct select on columns"""
    distinct_on: [redeam_channel_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redeam_channel_product_order_by!]

    """filter the rows returned"""
    where: redeam_channel_product_bool_exp
  ): [redeam_channel_product!]!

  """An aggregated array relationship"""
  channel_products_aggregate(
    """distinct select on columns"""
    distinct_on: [redeam_channel_product_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redeam_channel_product_order_by!]

    """filter the rows returned"""
    where: redeam_channel_product_bool_exp
  ): redeam_channel_product_aggregate!
  booking_cutoff: interval
  booking_info(
    """JSON select path"""
    path: String
  ): jsonb
  cancel_cutoff_after: interval
  cancel_cutoff_before: interval

  """An object relationship"""
  city: city
  city_id: String
  created_at: timestamptz
  custom_msg: String

  """An object relationship"""
  details: products_view
  duration: interval
  id: String!
  name: String!

  """An array relationship"""
  options(
    """distinct select on columns"""
    distinct_on: [options_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [options_order_by!]

    """filter the rows returned"""
    where: options_bool_exp
  ): [options!]!

  """An aggregated array relationship"""
  options_aggregate(
    """distinct select on columns"""
    distinct_on: [options_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [options_order_by!]

    """filter the rows returned"""
    where: options_bool_exp
  ): options_aggregate!
  pickup_bounds(
    """JSON select path"""
    path: String
  ): jsonb
  price(
    """JSON select path"""
    path: String
  ): jsonb
  product_type: String

  """An array relationship"""
  products_attractions(
    """distinct select on columns"""
    distinct_on: [products_attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_attractions_order_by!]

    """filter the rows returned"""
    where: products_attractions_bool_exp
  ): [products_attractions!]!

  """An aggregated array relationship"""
  products_attractions_aggregate(
    """distinct select on columns"""
    distinct_on: [products_attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_attractions_order_by!]

    """filter the rows returned"""
    where: products_attractions_bool_exp
  ): products_attractions_aggregate!
  quantity: numrange!

  """REDEAM: Code"""
  reference: String

  """An object relationship"""
  supplier: redeam_suppliers!
  supplier_id: String!
  updated_at: timestamptz
}

"""
aggregated selection of "boat.products"
"""
type products_aggregate {
  aggregate: products_aggregate_fields
  nodes: [products!]!
}

"""
aggregate fields of "boat.products"
"""
type products_aggregate_fields {
  count(columns: [products_select_column!], distinct: Boolean): Int
  max: products_max_fields
  min: products_min_fields
}

"""
order by aggregate values of table "boat.products"
"""
input products_aggregate_order_by {
  count: order_by
  max: products_max_order_by
  min: products_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input products_append_input {
  booking_info: jsonb
  pickup_bounds: jsonb
  price: jsonb
}

"""
input type for inserting array relation for remote table "boat.products"
"""
input products_arr_rel_insert_input {
  data: [products_insert_input!]!
  on_conflict: products_on_conflict
}

"""
columns and relationships of "boat.products_attractions"
"""
type products_attractions {
  """An object relationship"""
  attraction: attractions!
  attraction_id: String!

  """An object relationship"""
  product: products!
  product_id: String!
}

"""
aggregated selection of "boat.products_attractions"
"""
type products_attractions_aggregate {
  aggregate: products_attractions_aggregate_fields
  nodes: [products_attractions!]!
}

"""
aggregate fields of "boat.products_attractions"
"""
type products_attractions_aggregate_fields {
  count(columns: [products_attractions_select_column!], distinct: Boolean): Int
  max: products_attractions_max_fields
  min: products_attractions_min_fields
}

"""
order by aggregate values of table "boat.products_attractions"
"""
input products_attractions_aggregate_order_by {
  count: order_by
  max: products_attractions_max_order_by
  min: products_attractions_min_order_by
}

"""
input type for inserting array relation for remote table "boat.products_attractions"
"""
input products_attractions_arr_rel_insert_input {
  data: [products_attractions_insert_input!]!
  on_conflict: products_attractions_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.products_attractions". All fields are combined with a logical 'AND'.
"""
input products_attractions_bool_exp {
  _and: [products_attractions_bool_exp]
  _not: products_attractions_bool_exp
  _or: [products_attractions_bool_exp]
  attraction: attractions_bool_exp
  attraction_id: String_comparison_exp
  product: products_bool_exp
  product_id: String_comparison_exp
}

"""
unique or primary key constraints on table "boat.products_attractions"
"""
enum products_attractions_constraint {
  """unique or primary key constraint"""
  products_attractions_pkey
}

"""
input type for inserting data into table "boat.products_attractions"
"""
input products_attractions_insert_input {
  attraction: attractions_obj_rel_insert_input
  attraction_id: String
  product: products_obj_rel_insert_input
  product_id: String
}

"""aggregate max on columns"""
type products_attractions_max_fields {
  attraction_id: String
  product_id: String
}

"""
order by max() on columns of table "boat.products_attractions"
"""
input products_attractions_max_order_by {
  attraction_id: order_by
  product_id: order_by
}

"""aggregate min on columns"""
type products_attractions_min_fields {
  attraction_id: String
  product_id: String
}

"""
order by min() on columns of table "boat.products_attractions"
"""
input products_attractions_min_order_by {
  attraction_id: order_by
  product_id: order_by
}

"""
response of any mutation on the table "boat.products_attractions"
"""
type products_attractions_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [products_attractions!]!
}

"""
input type for inserting object relation for remote table "boat.products_attractions"
"""
input products_attractions_obj_rel_insert_input {
  data: products_attractions_insert_input!
  on_conflict: products_attractions_on_conflict
}

"""
on conflict condition type for table "boat.products_attractions"
"""
input products_attractions_on_conflict {
  constraint: products_attractions_constraint!
  update_columns: [products_attractions_update_column!]!
  where: products_attractions_bool_exp
}

"""
ordering options when selecting data from "boat.products_attractions"
"""
input products_attractions_order_by {
  attraction: attractions_order_by
  attraction_id: order_by
  product: products_order_by
  product_id: order_by
}

"""
primary key columns input for table: "boat.products_attractions"
"""
input products_attractions_pk_columns_input {
  attraction_id: String!
  product_id: String!
}

"""
select columns of table "boat.products_attractions"
"""
enum products_attractions_select_column {
  """column name"""
  attraction_id

  """column name"""
  product_id
}

"""
input type for updating data in table "boat.products_attractions"
"""
input products_attractions_set_input {
  attraction_id: String
  product_id: String
}

"""
update columns of table "boat.products_attractions"
"""
enum products_attractions_update_column {
  """column name"""
  attraction_id

  """column name"""
  product_id
}

"""
Boolean expression to filter rows from the table "boat.products". All fields are combined with a logical 'AND'.
"""
input products_bool_exp {
  _and: [products_bool_exp]
  _not: products_bool_exp
  _or: [products_bool_exp]
  active: Boolean_comparison_exp
  advertised_price: String_comparison_exp
  channel_products: redeam_channel_product_bool_exp
  booking_cutoff: interval_comparison_exp
  booking_info: jsonb_comparison_exp
  cancel_cutoff_after: interval_comparison_exp
  cancel_cutoff_before: interval_comparison_exp
  city: city_bool_exp
  city_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  custom_msg: String_comparison_exp
  details: products_view_bool_exp
  duration: interval_comparison_exp
  id: String_comparison_exp
  name: String_comparison_exp
  options: options_bool_exp
  pickup_bounds: jsonb_comparison_exp
  price: jsonb_comparison_exp
  product_type: String_comparison_exp
  products_attractions: products_attractions_bool_exp
  quantity: numrange_comparison_exp
  reference: String_comparison_exp
  supplier: redeam_suppliers_bool_exp
  supplier_id: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "boat.products"
"""
enum products_constraint {
  """unique or primary key constraint"""
  products_pkey

  """unique or primary key constraint"""
  products_reference_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input products_delete_at_path_input {
  booking_info: [String]
  pickup_bounds: [String]
  price: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input products_delete_elem_input {
  booking_info: Int
  pickup_bounds: Int
  price: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input products_delete_key_input {
  booking_info: String
  pickup_bounds: String
  price: String
}

"""
input type for inserting data into table "boat.products"
"""
input products_insert_input {
  active: Boolean
  advertised_price: String
  channel_products: redeam_channel_product_arr_rel_insert_input
  booking_cutoff: interval
  booking_info: jsonb
  cancel_cutoff_after: interval
  cancel_cutoff_before: interval
  city: city_obj_rel_insert_input
  city_id: String
  created_at: timestamptz
  custom_msg: String
  details: products_view_obj_rel_insert_input
  duration: interval
  id: String
  name: String
  options: options_arr_rel_insert_input
  pickup_bounds: jsonb
  price: jsonb
  product_type: String
  products_attractions: products_attractions_arr_rel_insert_input
  quantity: numrange
  reference: String
  supplier: redeam_suppliers_obj_rel_insert_input
  supplier_id: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type products_max_fields {
  advertised_price: String
  city_id: String
  created_at: timestamptz
  custom_msg: String
  id: String
  name: String
  product_type: String
  reference: String
  supplier_id: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "boat.products"
"""
input products_max_order_by {
  advertised_price: order_by
  city_id: order_by
  created_at: order_by
  custom_msg: order_by
  id: order_by
  name: order_by
  product_type: order_by
  reference: order_by
  supplier_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type products_min_fields {
  advertised_price: String
  city_id: String
  created_at: timestamptz
  custom_msg: String
  id: String
  name: String
  product_type: String
  reference: String
  supplier_id: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "boat.products"
"""
input products_min_order_by {
  advertised_price: order_by
  city_id: order_by
  created_at: order_by
  custom_msg: order_by
  id: order_by
  name: order_by
  product_type: order_by
  reference: order_by
  supplier_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "boat.products"
"""
type products_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [products!]!
}

"""
input type for inserting object relation for remote table "boat.products"
"""
input products_obj_rel_insert_input {
  data: products_insert_input!
  on_conflict: products_on_conflict
}

"""
on conflict condition type for table "boat.products"
"""
input products_on_conflict {
  constraint: products_constraint!
  update_columns: [products_update_column!]!
  where: products_bool_exp
}

"""
ordering options when selecting data from "boat.products"
"""
input products_order_by {
  active: order_by
  advertised_price: order_by
  channel_products_aggregate: redeam_channel_product_aggregate_order_by
  booking_cutoff: order_by
  booking_info: order_by
  cancel_cutoff_after: order_by
  cancel_cutoff_before: order_by
  city: city_order_by
  city_id: order_by
  created_at: order_by
  custom_msg: order_by
  details: products_view_order_by
  duration: order_by
  id: order_by
  name: order_by
  options_aggregate: options_aggregate_order_by
  pickup_bounds: order_by
  price: order_by
  product_type: order_by
  products_attractions_aggregate: products_attractions_aggregate_order_by
  quantity: order_by
  reference: order_by
  supplier: redeam_suppliers_order_by
  supplier_id: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "boat.products"
"""
input products_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input products_prepend_input {
  booking_info: jsonb
  pickup_bounds: jsonb
  price: jsonb
}

"""
select columns of table "boat.products"
"""
enum products_select_column {
  """column name"""
  active

  """column name"""
  advertised_price

  """column name"""
  booking_cutoff

  """column name"""
  booking_info

  """column name"""
  cancel_cutoff_after

  """column name"""
  cancel_cutoff_before

  """column name"""
  city_id

  """column name"""
  created_at

  """column name"""
  custom_msg

  """column name"""
  duration

  """column name"""
  id

  """column name"""
  name

  """column name"""
  pickup_bounds

  """column name"""
  price

  """column name"""
  product_type

  """column name"""
  quantity

  """column name"""
  reference

  """column name"""
  supplier_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "boat.products"
"""
input products_set_input {
  active: Boolean
  advertised_price: String
  booking_cutoff: interval
  booking_info: jsonb
  cancel_cutoff_after: interval
  cancel_cutoff_before: interval
  city_id: String
  created_at: timestamptz
  custom_msg: String
  duration: interval
  id: String
  name: String
  pickup_bounds: jsonb
  price: jsonb
  product_type: String
  quantity: numrange
  reference: String
  supplier_id: String
  updated_at: timestamptz
}

"""
update columns of table "boat.products"
"""
enum products_update_column {
  """column name"""
  active

  """column name"""
  advertised_price

  """column name"""
  booking_cutoff

  """column name"""
  booking_info

  """column name"""
  cancel_cutoff_after

  """column name"""
  cancel_cutoff_before

  """column name"""
  city_id

  """column name"""
  created_at

  """column name"""
  custom_msg

  """column name"""
  duration

  """column name"""
  id

  """column name"""
  name

  """column name"""
  pickup_bounds

  """column name"""
  price

  """column name"""
  product_type

  """column name"""
  quantity

  """column name"""
  reference

  """column name"""
  supplier_id

  """column name"""
  updated_at
}

"""
columns and relationships of "boat.products_view"
"""
type products_view {
  cancel_after: float8
  cancel_before: float8
  id: String

  """An object relationship"""
  main: products
}

"""
aggregated selection of "boat.products_view"
"""
type products_view_aggregate {
  aggregate: products_view_aggregate_fields
  nodes: [products_view!]!
}

"""
aggregate fields of "boat.products_view"
"""
type products_view_aggregate_fields {
  avg: products_view_avg_fields
  count(columns: [products_view_select_column!], distinct: Boolean): Int
  max: products_view_max_fields
  min: products_view_min_fields
  stddev: products_view_stddev_fields
  stddev_pop: products_view_stddev_pop_fields
  stddev_samp: products_view_stddev_samp_fields
  sum: products_view_sum_fields
  var_pop: products_view_var_pop_fields
  var_samp: products_view_var_samp_fields
  variance: products_view_variance_fields
}

"""
order by aggregate values of table "boat.products_view"
"""
input products_view_aggregate_order_by {
  avg: products_view_avg_order_by
  count: order_by
  max: products_view_max_order_by
  min: products_view_min_order_by
  stddev: products_view_stddev_order_by
  stddev_pop: products_view_stddev_pop_order_by
  stddev_samp: products_view_stddev_samp_order_by
  sum: products_view_sum_order_by
  var_pop: products_view_var_pop_order_by
  var_samp: products_view_var_samp_order_by
  variance: products_view_variance_order_by
}

"""
input type for inserting array relation for remote table "boat.products_view"
"""
input products_view_arr_rel_insert_input {
  data: [products_view_insert_input!]!
}

"""aggregate avg on columns"""
type products_view_avg_fields {
  cancel_after: Float
  cancel_before: Float
}

"""
order by avg() on columns of table "boat.products_view"
"""
input products_view_avg_order_by {
  cancel_after: order_by
  cancel_before: order_by
}

"""
Boolean expression to filter rows from the table "boat.products_view". All fields are combined with a logical 'AND'.
"""
input products_view_bool_exp {
  _and: [products_view_bool_exp]
  _not: products_view_bool_exp
  _or: [products_view_bool_exp]
  cancel_after: float8_comparison_exp
  cancel_before: float8_comparison_exp
  id: String_comparison_exp
  main: products_bool_exp
}

"""
input type for incrementing integer column in table "boat.products_view"
"""
input products_view_inc_input {
  cancel_after: float8
  cancel_before: float8
}

"""
input type for inserting data into table "boat.products_view"
"""
input products_view_insert_input {
  cancel_after: float8
  cancel_before: float8
  id: String
  main: products_obj_rel_insert_input
}

"""aggregate max on columns"""
type products_view_max_fields {
  cancel_after: float8
  cancel_before: float8
  id: String
}

"""
order by max() on columns of table "boat.products_view"
"""
input products_view_max_order_by {
  cancel_after: order_by
  cancel_before: order_by
  id: order_by
}

"""aggregate min on columns"""
type products_view_min_fields {
  cancel_after: float8
  cancel_before: float8
  id: String
}

"""
order by min() on columns of table "boat.products_view"
"""
input products_view_min_order_by {
  cancel_after: order_by
  cancel_before: order_by
  id: order_by
}

"""
response of any mutation on the table "boat.products_view"
"""
type products_view_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [products_view!]!
}

"""
input type for inserting object relation for remote table "boat.products_view"
"""
input products_view_obj_rel_insert_input {
  data: products_view_insert_input!
}

"""
ordering options when selecting data from "boat.products_view"
"""
input products_view_order_by {
  cancel_after: order_by
  cancel_before: order_by
  id: order_by
  main: products_order_by
}

"""
select columns of table "boat.products_view"
"""
enum products_view_select_column {
  """column name"""
  cancel_after

  """column name"""
  cancel_before

  """column name"""
  id
}

"""
input type for updating data in table "boat.products_view"
"""
input products_view_set_input {
  cancel_after: float8
  cancel_before: float8
  id: String
}

"""aggregate stddev on columns"""
type products_view_stddev_fields {
  cancel_after: Float
  cancel_before: Float
}

"""
order by stddev() on columns of table "boat.products_view"
"""
input products_view_stddev_order_by {
  cancel_after: order_by
  cancel_before: order_by
}

"""aggregate stddev_pop on columns"""
type products_view_stddev_pop_fields {
  cancel_after: Float
  cancel_before: Float
}

"""
order by stddev_pop() on columns of table "boat.products_view"
"""
input products_view_stddev_pop_order_by {
  cancel_after: order_by
  cancel_before: order_by
}

"""aggregate stddev_samp on columns"""
type products_view_stddev_samp_fields {
  cancel_after: Float
  cancel_before: Float
}

"""
order by stddev_samp() on columns of table "boat.products_view"
"""
input products_view_stddev_samp_order_by {
  cancel_after: order_by
  cancel_before: order_by
}

"""aggregate sum on columns"""
type products_view_sum_fields {
  cancel_after: float8
  cancel_before: float8
}

"""
order by sum() on columns of table "boat.products_view"
"""
input products_view_sum_order_by {
  cancel_after: order_by
  cancel_before: order_by
}

"""aggregate var_pop on columns"""
type products_view_var_pop_fields {
  cancel_after: Float
  cancel_before: Float
}

"""
order by var_pop() on columns of table "boat.products_view"
"""
input products_view_var_pop_order_by {
  cancel_after: order_by
  cancel_before: order_by
}

"""aggregate var_samp on columns"""
type products_view_var_samp_fields {
  cancel_after: Float
  cancel_before: Float
}

"""
order by var_samp() on columns of table "boat.products_view"
"""
input products_view_var_samp_order_by {
  cancel_after: order_by
  cancel_before: order_by
}

"""aggregate variance on columns"""
type products_view_variance_fields {
  cancel_after: Float
  cancel_before: Float
}

"""
order by variance() on columns of table "boat.products_view"
"""
input products_view_variance_order_by {
  cancel_after: order_by
  cancel_before: order_by
}

"""
columns and relationships of "boat.resources"
"""
type resources {
  """An object relationship"""
  availability: availabilities!
  availability_id: String!
  created_at: timestamptz
  id: String!
  resources: Int!
  seats: Int!

  """An object relationship"""
  session: sessions
  sessions_id: String

  """ENUM: [VAN, BOAT, OTHER]"""
  type: String!
  updated_at: timestamptz
}

"""
aggregated selection of "boat.resources"
"""
type resources_aggregate {
  aggregate: resources_aggregate_fields
  nodes: [resources!]!
}

"""
aggregate fields of "boat.resources"
"""
type resources_aggregate_fields {
  avg: resources_avg_fields
  count(columns: [resources_select_column!], distinct: Boolean): Int
  max: resources_max_fields
  min: resources_min_fields
  stddev: resources_stddev_fields
  stddev_pop: resources_stddev_pop_fields
  stddev_samp: resources_stddev_samp_fields
  sum: resources_sum_fields
  var_pop: resources_var_pop_fields
  var_samp: resources_var_samp_fields
  variance: resources_variance_fields
}

"""
order by aggregate values of table "boat.resources"
"""
input resources_aggregate_order_by {
  avg: resources_avg_order_by
  count: order_by
  max: resources_max_order_by
  min: resources_min_order_by
  stddev: resources_stddev_order_by
  stddev_pop: resources_stddev_pop_order_by
  stddev_samp: resources_stddev_samp_order_by
  sum: resources_sum_order_by
  var_pop: resources_var_pop_order_by
  var_samp: resources_var_samp_order_by
  variance: resources_variance_order_by
}

"""
input type for inserting array relation for remote table "boat.resources"
"""
input resources_arr_rel_insert_input {
  data: [resources_insert_input!]!
  on_conflict: resources_on_conflict
}

"""aggregate avg on columns"""
type resources_avg_fields {
  resources: Float
  seats: Float
}

"""
order by avg() on columns of table "boat.resources"
"""
input resources_avg_order_by {
  resources: order_by
  seats: order_by
}

"""
Boolean expression to filter rows from the table "boat.resources". All fields are combined with a logical 'AND'.
"""
input resources_bool_exp {
  _and: [resources_bool_exp]
  _not: resources_bool_exp
  _or: [resources_bool_exp]
  availability: availabilities_bool_exp
  availability_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  resources: Int_comparison_exp
  seats: Int_comparison_exp
  session: sessions_bool_exp
  sessions_id: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "boat.resources"
"""
enum resources_constraint {
  """unique or primary key constraint"""
  resources_pkey
}

"""
input type for incrementing integer column in table "boat.resources"
"""
input resources_inc_input {
  resources: Int
  seats: Int
}

"""
input type for inserting data into table "boat.resources"
"""
input resources_insert_input {
  availability: availabilities_obj_rel_insert_input
  availability_id: String
  created_at: timestamptz
  id: String
  resources: Int
  seats: Int
  session: sessions_obj_rel_insert_input
  sessions_id: String
  type: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type resources_max_fields {
  availability_id: String
  created_at: timestamptz
  id: String
  resources: Int
  seats: Int
  sessions_id: String
  type: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "boat.resources"
"""
input resources_max_order_by {
  availability_id: order_by
  created_at: order_by
  id: order_by
  resources: order_by
  seats: order_by
  sessions_id: order_by
  type: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type resources_min_fields {
  availability_id: String
  created_at: timestamptz
  id: String
  resources: Int
  seats: Int
  sessions_id: String
  type: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "boat.resources"
"""
input resources_min_order_by {
  availability_id: order_by
  created_at: order_by
  id: order_by
  resources: order_by
  seats: order_by
  sessions_id: order_by
  type: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "boat.resources"
"""
type resources_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [resources!]!
}

"""
input type for inserting object relation for remote table "boat.resources"
"""
input resources_obj_rel_insert_input {
  data: resources_insert_input!
  on_conflict: resources_on_conflict
}

"""
on conflict condition type for table "boat.resources"
"""
input resources_on_conflict {
  constraint: resources_constraint!
  update_columns: [resources_update_column!]!
  where: resources_bool_exp
}

"""
ordering options when selecting data from "boat.resources"
"""
input resources_order_by {
  availability: availabilities_order_by
  availability_id: order_by
  created_at: order_by
  id: order_by
  resources: order_by
  seats: order_by
  session: sessions_order_by
  sessions_id: order_by
  type: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "boat.resources"
"""
input resources_pk_columns_input {
  id: String!
}

"""
select columns of table "boat.resources"
"""
enum resources_select_column {
  """column name"""
  availability_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  resources

  """column name"""
  seats

  """column name"""
  sessions_id

  """column name"""
  type

  """column name"""
  updated_at
}

"""
input type for updating data in table "boat.resources"
"""
input resources_set_input {
  availability_id: String
  created_at: timestamptz
  id: String
  resources: Int
  seats: Int
  sessions_id: String
  type: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type resources_stddev_fields {
  resources: Float
  seats: Float
}

"""
order by stddev() on columns of table "boat.resources"
"""
input resources_stddev_order_by {
  resources: order_by
  seats: order_by
}

"""aggregate stddev_pop on columns"""
type resources_stddev_pop_fields {
  resources: Float
  seats: Float
}

"""
order by stddev_pop() on columns of table "boat.resources"
"""
input resources_stddev_pop_order_by {
  resources: order_by
  seats: order_by
}

"""aggregate stddev_samp on columns"""
type resources_stddev_samp_fields {
  resources: Float
  seats: Float
}

"""
order by stddev_samp() on columns of table "boat.resources"
"""
input resources_stddev_samp_order_by {
  resources: order_by
  seats: order_by
}

"""aggregate sum on columns"""
type resources_sum_fields {
  resources: Int
  seats: Int
}

"""
order by sum() on columns of table "boat.resources"
"""
input resources_sum_order_by {
  resources: order_by
  seats: order_by
}

"""
update columns of table "boat.resources"
"""
enum resources_update_column {
  """column name"""
  availability_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  resources

  """column name"""
  seats

  """column name"""
  sessions_id

  """column name"""
  type

  """column name"""
  updated_at
}

"""aggregate var_pop on columns"""
type resources_var_pop_fields {
  resources: Float
  seats: Float
}

"""
order by var_pop() on columns of table "boat.resources"
"""
input resources_var_pop_order_by {
  resources: order_by
  seats: order_by
}

"""aggregate var_samp on columns"""
type resources_var_samp_fields {
  resources: Float
  seats: Float
}

"""
order by var_samp() on columns of table "boat.resources"
"""
input resources_var_samp_order_by {
  resources: order_by
  seats: order_by
}

"""aggregate variance on columns"""
type resources_variance_fields {
  resources: Float
  seats: Float
}

"""
order by variance() on columns of table "boat.resources"
"""
input resources_variance_order_by {
  resources: order_by
  seats: order_by
}

"""
columns and relationships of "boat.sessions"
"""
type sessions {
  """An object relationship"""
  availability: availabilities!
  availability_id: String!
  created_at: timestamptz
  date: daterange!
  id: String!
  pax: numrange!

  """An array relationship"""
  resources(
    """distinct select on columns"""
    distinct_on: [resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resources_order_by!]

    """filter the rows returned"""
    where: resources_bool_exp
  ): [resources!]!

  """An aggregated array relationship"""
  resources_aggregate(
    """distinct select on columns"""
    distinct_on: [resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resources_order_by!]

    """filter the rows returned"""
    where: resources_bool_exp
  ): resources_aggregate!
  updated_at: timestamptz
}

"""
aggregated selection of "boat.sessions"
"""
type sessions_aggregate {
  aggregate: sessions_aggregate_fields
  nodes: [sessions!]!
}

"""
aggregate fields of "boat.sessions"
"""
type sessions_aggregate_fields {
  count(columns: [sessions_select_column!], distinct: Boolean): Int
  max: sessions_max_fields
  min: sessions_min_fields
}

"""
order by aggregate values of table "boat.sessions"
"""
input sessions_aggregate_order_by {
  count: order_by
  max: sessions_max_order_by
  min: sessions_min_order_by
}

"""
input type for inserting array relation for remote table "boat.sessions"
"""
input sessions_arr_rel_insert_input {
  data: [sessions_insert_input!]!
  on_conflict: sessions_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.sessions". All fields are combined with a logical 'AND'.
"""
input sessions_bool_exp {
  _and: [sessions_bool_exp]
  _not: sessions_bool_exp
  _or: [sessions_bool_exp]
  availability: availabilities_bool_exp
  availability_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  date: daterange_comparison_exp
  id: String_comparison_exp
  pax: numrange_comparison_exp
  resources: resources_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "boat.sessions"
"""
enum sessions_constraint {
  """unique or primary key constraint"""
  sessions_id_key

  """unique or primary key constraint"""
  sessions_pkey
}

"""
input type for inserting data into table "boat.sessions"
"""
input sessions_insert_input {
  availability: availabilities_obj_rel_insert_input
  availability_id: String
  created_at: timestamptz
  date: daterange
  id: String
  pax: numrange
  resources: resources_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type sessions_max_fields {
  availability_id: String
  created_at: timestamptz
  id: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "boat.sessions"
"""
input sessions_max_order_by {
  availability_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type sessions_min_fields {
  availability_id: String
  created_at: timestamptz
  id: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "boat.sessions"
"""
input sessions_min_order_by {
  availability_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "boat.sessions"
"""
type sessions_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [sessions!]!
}

"""
input type for inserting object relation for remote table "boat.sessions"
"""
input sessions_obj_rel_insert_input {
  data: sessions_insert_input!
  on_conflict: sessions_on_conflict
}

"""
on conflict condition type for table "boat.sessions"
"""
input sessions_on_conflict {
  constraint: sessions_constraint!
  update_columns: [sessions_update_column!]!
  where: sessions_bool_exp
}

"""
ordering options when selecting data from "boat.sessions"
"""
input sessions_order_by {
  availability: availabilities_order_by
  availability_id: order_by
  created_at: order_by
  date: order_by
  id: order_by
  pax: order_by
  resources_aggregate: resources_aggregate_order_by
  updated_at: order_by
}

"""
primary key columns input for table: "boat.sessions"
"""
input sessions_pk_columns_input {
  id: String!
}

"""
select columns of table "boat.sessions"
"""
enum sessions_select_column {
  """column name"""
  availability_id

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  id

  """column name"""
  pax

  """column name"""
  updated_at
}

"""
input type for updating data in table "boat.sessions"
"""
input sessions_set_input {
  availability_id: String
  created_at: timestamptz
  date: daterange
  id: String
  pax: numrange
  updated_at: timestamptz
}

"""
update columns of table "boat.sessions"
"""
enum sessions_update_column {
  """column name"""
  availability_id

  """column name"""
  created_at

  """column name"""
  date

  """column name"""
  id

  """column name"""
  pax

  """column name"""
  updated_at
}

"""
columns and relationships of "boat.subtasks"
"""
type subtasks {
  """An object relationship"""
  booking: booking
  booking_id: String!
  created_at: timestamptz!
  id: String!
  status: String!
  task: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "boat.subtasks"
"""
type subtasks_aggregate {
  aggregate: subtasks_aggregate_fields
  nodes: [subtasks!]!
}

"""
aggregate fields of "boat.subtasks"
"""
type subtasks_aggregate_fields {
  count(columns: [subtasks_select_column!], distinct: Boolean): Int
  max: subtasks_max_fields
  min: subtasks_min_fields
}

"""
order by aggregate values of table "boat.subtasks"
"""
input subtasks_aggregate_order_by {
  count: order_by
  max: subtasks_max_order_by
  min: subtasks_min_order_by
}

"""
input type for inserting array relation for remote table "boat.subtasks"
"""
input subtasks_arr_rel_insert_input {
  data: [subtasks_insert_input!]!
  on_conflict: subtasks_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.subtasks". All fields are combined with a logical 'AND'.
"""
input subtasks_bool_exp {
  _and: [subtasks_bool_exp]
  _not: subtasks_bool_exp
  _or: [subtasks_bool_exp]
  booking: booking_bool_exp
  booking_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  status: String_comparison_exp
  task: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "boat.subtasks"
"""
enum subtasks_constraint {
  """unique or primary key constraint"""
  subtasks_pkey
}

"""
input type for inserting data into table "boat.subtasks"
"""
input subtasks_insert_input {
  booking: booking_obj_rel_insert_input
  booking_id: String
  created_at: timestamptz
  id: String
  status: String
  task: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type subtasks_max_fields {
  booking_id: String
  created_at: timestamptz
  id: String
  status: String
  task: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "boat.subtasks"
"""
input subtasks_max_order_by {
  booking_id: order_by
  created_at: order_by
  id: order_by
  status: order_by
  task: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type subtasks_min_fields {
  booking_id: String
  created_at: timestamptz
  id: String
  status: String
  task: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "boat.subtasks"
"""
input subtasks_min_order_by {
  booking_id: order_by
  created_at: order_by
  id: order_by
  status: order_by
  task: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "boat.subtasks"
"""
type subtasks_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [subtasks!]!
}

"""
input type for inserting object relation for remote table "boat.subtasks"
"""
input subtasks_obj_rel_insert_input {
  data: subtasks_insert_input!
  on_conflict: subtasks_on_conflict
}

"""
on conflict condition type for table "boat.subtasks"
"""
input subtasks_on_conflict {
  constraint: subtasks_constraint!
  update_columns: [subtasks_update_column!]!
  where: subtasks_bool_exp
}

"""
ordering options when selecting data from "boat.subtasks"
"""
input subtasks_order_by {
  booking: booking_order_by
  booking_id: order_by
  created_at: order_by
  id: order_by
  status: order_by
  task: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "boat.subtasks"
"""
input subtasks_pk_columns_input {
  id: String!
}

"""
select columns of table "boat.subtasks"
"""
enum subtasks_select_column {
  """column name"""
  booking_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  status

  """column name"""
  task

  """column name"""
  updated_at
}

"""
input type for updating data in table "boat.subtasks"
"""
input subtasks_set_input {
  booking_id: String
  created_at: timestamptz
  id: String
  status: String
  task: String
  updated_at: timestamptz
}

"""
update columns of table "boat.subtasks"
"""
enum subtasks_update_column {
  """column name"""
  booking_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  status

  """column name"""
  task

  """column name"""
  updated_at
}

"""
columns and relationships of "boat.test_table"
"""
type test_table {
  id: String!
  name: String!
}

"""
aggregated selection of "boat.test_table"
"""
type test_table_aggregate {
  aggregate: test_table_aggregate_fields
  nodes: [test_table!]!
}

"""
aggregate fields of "boat.test_table"
"""
type test_table_aggregate_fields {
  count(columns: [test_table_select_column!], distinct: Boolean): Int
  max: test_table_max_fields
  min: test_table_min_fields
}

"""
order by aggregate values of table "boat.test_table"
"""
input test_table_aggregate_order_by {
  count: order_by
  max: test_table_max_order_by
  min: test_table_min_order_by
}

"""
input type for inserting array relation for remote table "boat.test_table"
"""
input test_table_arr_rel_insert_input {
  data: [test_table_insert_input!]!
  on_conflict: test_table_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.test_table". All fields are combined with a logical 'AND'.
"""
input test_table_bool_exp {
  _and: [test_table_bool_exp]
  _not: test_table_bool_exp
  _or: [test_table_bool_exp]
  id: String_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "boat.test_table"
"""
enum test_table_constraint {
  """unique or primary key constraint"""
  test_table_pkey
}

"""
input type for inserting data into table "boat.test_table"
"""
input test_table_insert_input {
  id: String
  name: String
}

"""aggregate max on columns"""
type test_table_max_fields {
  id: String
  name: String
}

"""
order by max() on columns of table "boat.test_table"
"""
input test_table_max_order_by {
  id: order_by
  name: order_by
}

"""aggregate min on columns"""
type test_table_min_fields {
  id: String
  name: String
}

"""
order by min() on columns of table "boat.test_table"
"""
input test_table_min_order_by {
  id: order_by
  name: order_by
}

"""
response of any mutation on the table "boat.test_table"
"""
type test_table_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [test_table!]!
}

"""
input type for inserting object relation for remote table "boat.test_table"
"""
input test_table_obj_rel_insert_input {
  data: test_table_insert_input!
  on_conflict: test_table_on_conflict
}

"""
on conflict condition type for table "boat.test_table"
"""
input test_table_on_conflict {
  constraint: test_table_constraint!
  update_columns: [test_table_update_column!]!
  where: test_table_bool_exp
}

"""
ordering options when selecting data from "boat.test_table"
"""
input test_table_order_by {
  id: order_by
  name: order_by
}

"""
primary key columns input for table: "boat.test_table"
"""
input test_table_pk_columns_input {
  id: String!
}

"""
select columns of table "boat.test_table"
"""
enum test_table_select_column {
  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "boat.test_table"
"""
input test_table_set_input {
  id: String
  name: String
}

"""
update columns of table "boat.test_table"
"""
enum test_table_update_column {
  """column name"""
  id

  """column name"""
  name
}

"""
columns and relationships of "boat.transactions"
"""
type transactions {
  """An object relationship"""
  booking: booking
  booking_id: String
  created_at: timestamptz!

  """An object relationship"""
  customer: customers
  customer_id: String
  date: timestamptz!
  reason: String!
  stripe_id: String!
  type: String!
  updated_at: timestamptz!
  value: String!
}

"""
aggregated selection of "boat.transactions"
"""
type transactions_aggregate {
  aggregate: transactions_aggregate_fields
  nodes: [transactions!]!
}

"""
aggregate fields of "boat.transactions"
"""
type transactions_aggregate_fields {
  count(columns: [transactions_select_column!], distinct: Boolean): Int
  max: transactions_max_fields
  min: transactions_min_fields
}

"""
order by aggregate values of table "boat.transactions"
"""
input transactions_aggregate_order_by {
  count: order_by
  max: transactions_max_order_by
  min: transactions_min_order_by
}

"""
input type for inserting array relation for remote table "boat.transactions"
"""
input transactions_arr_rel_insert_input {
  data: [transactions_insert_input!]!
  on_conflict: transactions_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.transactions". All fields are combined with a logical 'AND'.
"""
input transactions_bool_exp {
  _and: [transactions_bool_exp]
  _not: transactions_bool_exp
  _or: [transactions_bool_exp]
  booking: booking_bool_exp
  booking_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  customer: customers_bool_exp
  customer_id: String_comparison_exp
  date: timestamptz_comparison_exp
  reason: String_comparison_exp
  stripe_id: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "boat.transactions"
"""
enum transactions_constraint {
  """unique or primary key constraint"""
  transactions_pkey
}

"""
input type for inserting data into table "boat.transactions"
"""
input transactions_insert_input {
  booking: booking_obj_rel_insert_input
  booking_id: String
  created_at: timestamptz
  customer: customers_obj_rel_insert_input
  customer_id: String
  date: timestamptz
  reason: String
  stripe_id: String
  type: String
  updated_at: timestamptz
  value: String
}

"""aggregate max on columns"""
type transactions_max_fields {
  booking_id: String
  created_at: timestamptz
  customer_id: String
  date: timestamptz
  reason: String
  stripe_id: String
  type: String
  updated_at: timestamptz
  value: String
}

"""
order by max() on columns of table "boat.transactions"
"""
input transactions_max_order_by {
  booking_id: order_by
  created_at: order_by
  customer_id: order_by
  date: order_by
  reason: order_by
  stripe_id: order_by
  type: order_by
  updated_at: order_by
  value: order_by
}

"""aggregate min on columns"""
type transactions_min_fields {
  booking_id: String
  created_at: timestamptz
  customer_id: String
  date: timestamptz
  reason: String
  stripe_id: String
  type: String
  updated_at: timestamptz
  value: String
}

"""
order by min() on columns of table "boat.transactions"
"""
input transactions_min_order_by {
  booking_id: order_by
  created_at: order_by
  customer_id: order_by
  date: order_by
  reason: order_by
  stripe_id: order_by
  type: order_by
  updated_at: order_by
  value: order_by
}

"""
response of any mutation on the table "boat.transactions"
"""
type transactions_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [transactions!]!
}

"""
input type for inserting object relation for remote table "boat.transactions"
"""
input transactions_obj_rel_insert_input {
  data: transactions_insert_input!
  on_conflict: transactions_on_conflict
}

"""
on conflict condition type for table "boat.transactions"
"""
input transactions_on_conflict {
  constraint: transactions_constraint!
  update_columns: [transactions_update_column!]!
  where: transactions_bool_exp
}

"""
ordering options when selecting data from "boat.transactions"
"""
input transactions_order_by {
  booking: booking_order_by
  booking_id: order_by
  created_at: order_by
  customer: customers_order_by
  customer_id: order_by
  date: order_by
  reason: order_by
  stripe_id: order_by
  type: order_by
  updated_at: order_by
  value: order_by
}

"""
primary key columns input for table: "boat.transactions"
"""
input transactions_pk_columns_input {
  stripe_id: String!
}

"""
select columns of table "boat.transactions"
"""
enum transactions_select_column {
  """column name"""
  booking_id

  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  date

  """column name"""
  reason

  """column name"""
  stripe_id

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  value
}

"""
input type for updating data in table "boat.transactions"
"""
input transactions_set_input {
  booking_id: String
  created_at: timestamptz
  customer_id: String
  date: timestamptz
  reason: String
  stripe_id: String
  type: String
  updated_at: timestamptz
  value: String
}

"""
update columns of table "boat.transactions"
"""
enum transactions_update_column {
  """column name"""
  booking_id

  """column name"""
  created_at

  """column name"""
  customer_id

  """column name"""
  date

  """column name"""
  reason

  """column name"""
  stripe_id

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  value
}

"""
columns and relationships of "boat.units"
"""
type units {
  created_at: timestamptz
  id: String!
  internal_name: String!
  reference: String
  type: String!
  updated_at: timestamptz
}

"""
aggregated selection of "boat.units"
"""
type units_aggregate {
  aggregate: units_aggregate_fields
  nodes: [units!]!
}

"""
aggregate fields of "boat.units"
"""
type units_aggregate_fields {
  count(columns: [units_select_column!], distinct: Boolean): Int
  max: units_max_fields
  min: units_min_fields
}

"""
order by aggregate values of table "boat.units"
"""
input units_aggregate_order_by {
  count: order_by
  max: units_max_order_by
  min: units_min_order_by
}

"""
input type for inserting array relation for remote table "boat.units"
"""
input units_arr_rel_insert_input {
  data: [units_insert_input!]!
  on_conflict: units_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.units". All fields are combined with a logical 'AND'.
"""
input units_bool_exp {
  _and: [units_bool_exp]
  _not: units_bool_exp
  _or: [units_bool_exp]
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  internal_name: String_comparison_exp
  reference: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "boat.units"
"""
enum units_constraint {
  """unique or primary key constraint"""
  units_pkey
}

"""
input type for inserting data into table "boat.units"
"""
input units_insert_input {
  created_at: timestamptz
  id: String
  internal_name: String
  reference: String
  type: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type units_max_fields {
  created_at: timestamptz
  id: String
  internal_name: String
  reference: String
  type: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "boat.units"
"""
input units_max_order_by {
  created_at: order_by
  id: order_by
  internal_name: order_by
  reference: order_by
  type: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type units_min_fields {
  created_at: timestamptz
  id: String
  internal_name: String
  reference: String
  type: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "boat.units"
"""
input units_min_order_by {
  created_at: order_by
  id: order_by
  internal_name: order_by
  reference: order_by
  type: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "boat.units"
"""
type units_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [units!]!
}

"""
input type for inserting object relation for remote table "boat.units"
"""
input units_obj_rel_insert_input {
  data: units_insert_input!
  on_conflict: units_on_conflict
}

"""
on conflict condition type for table "boat.units"
"""
input units_on_conflict {
  constraint: units_constraint!
  update_columns: [units_update_column!]!
  where: units_bool_exp
}

"""
ordering options when selecting data from "boat.units"
"""
input units_order_by {
  created_at: order_by
  id: order_by
  internal_name: order_by
  reference: order_by
  type: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "boat.units"
"""
input units_pk_columns_input {
  id: String!
}

"""
select columns of table "boat.units"
"""
enum units_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  internal_name

  """column name"""
  reference

  """column name"""
  type

  """column name"""
  updated_at
}

"""
input type for updating data in table "boat.units"
"""
input units_set_input {
  created_at: timestamptz
  id: String
  internal_name: String
  reference: String
  type: String
  updated_at: timestamptz
}

"""
update columns of table "boat.units"
"""
enum units_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  internal_name

  """column name"""
  reference

  """column name"""
  type

  """column name"""
  updated_at
}

"""
columns and relationships of "user"
"""
type user {
  driver_id: String

  """An object relationship"""
  driver_info: Driver_BoxRocket
  email: String!
  id: String!

  """An array relationship"""
  invoice_boxrockets(
    """distinct select on columns"""
    distinct_on: [invoice_boxrocket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoice_boxrocket_order_by!]

    """filter the rows returned"""
    where: invoice_boxrocket_bool_exp
  ): [invoice_boxrocket!]!

  """An aggregated array relationship"""
  invoice_boxrockets_aggregate(
    """distinct select on columns"""
    distinct_on: [invoice_boxrocket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [invoice_boxrocket_order_by!]

    """filter the rows returned"""
    where: invoice_boxrocket_bool_exp
  ): invoice_boxrocket_aggregate!

  """An array relationship"""
  user_reports(
    """distinct select on columns"""
    distinct_on: [driver_report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [driver_report_order_by!]

    """filter the rows returned"""
    where: driver_report_bool_exp
  ): [driver_report!]!

  """An aggregated array relationship"""
  user_reports_aggregate(
    """distinct select on columns"""
    distinct_on: [driver_report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [driver_report_order_by!]

    """filter the rows returned"""
    where: driver_report_bool_exp
  ): driver_report_aggregate!
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  count(columns: [user_select_column!], distinct: Boolean): Int
  max: user_max_fields
  min: user_min_fields
}

"""
order by aggregate values of table "user"
"""
input user_aggregate_order_by {
  count: order_by
  max: user_max_order_by
  min: user_min_order_by
}

"""
input type for inserting array relation for remote table "user"
"""
input user_arr_rel_insert_input {
  data: [user_insert_input!]!
  on_conflict: user_on_conflict
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp]
  _not: user_bool_exp
  _or: [user_bool_exp]
  driver_id: String_comparison_exp
  driver_info: Driver_BoxRocket_bool_exp
  email: String_comparison_exp
  id: String_comparison_exp
  invoice_boxrockets: invoice_boxrocket_bool_exp
  user_reports: driver_report_bool_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """unique or primary key constraint"""
  User_driver_id_key

  """unique or primary key constraint"""
  User_email_key

  """unique or primary key constraint"""
  User_id_key

  """unique or primary key constraint"""
  User_pkey
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  driver_id: String
  driver_info: Driver_BoxRocket_obj_rel_insert_input
  email: String
  id: String
  invoice_boxrockets: invoice_boxrocket_arr_rel_insert_input
  user_reports: driver_report_arr_rel_insert_input
}

"""aggregate max on columns"""
type user_max_fields {
  driver_id: String
  email: String
  id: String
}

"""
order by max() on columns of table "user"
"""
input user_max_order_by {
  driver_id: order_by
  email: order_by
  id: order_by
}

"""aggregate min on columns"""
type user_min_fields {
  driver_id: String
  email: String
  id: String
}

"""
order by min() on columns of table "user"
"""
input user_min_order_by {
  driver_id: order_by
  email: order_by
  id: order_by
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!
  on_conflict: user_on_conflict
}

"""
on conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]!
  where: user_bool_exp
}

"""
ordering options when selecting data from "user"
"""
input user_order_by {
  driver_id: order_by
  driver_info: Driver_BoxRocket_order_by
  email: order_by
  id: order_by
  invoice_boxrockets_aggregate: invoice_boxrocket_aggregate_order_by
  user_reports_aggregate: driver_report_aggregate_order_by
}

"""
primary key columns input for table: "user"
"""
input user_pk_columns_input {
  id: String!
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  driver_id

  """column name"""
  email

  """column name"""
  id
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  driver_id: String
  email: String
  id: String
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  driver_id

  """column name"""
  email

  """column name"""
  id
}

"""
columns and relationships of "boat.users"
"""
type users {
  """An array relationship"""
  availability_groups(
    """distinct select on columns"""
    distinct_on: [availability_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availability_groups_order_by!]

    """filter the rows returned"""
    where: availability_groups_bool_exp
  ): [availability_groups!]!

  """An aggregated array relationship"""
  availability_groups_aggregate(
    """distinct select on columns"""
    distinct_on: [availability_groups_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availability_groups_order_by!]

    """filter the rows returned"""
    where: availability_groups_bool_exp
  ): availability_groups_aggregate!
  email: String!
  first_name: String
  id: String!
  last_name: String
}

"""
aggregated selection of "boat.users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "boat.users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "boat.users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""
input type for inserting array relation for remote table "boat.users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "boat.users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp]
  _not: users_bool_exp
  _or: [users_bool_exp]
  availability_groups: availability_groups_bool_exp
  email: String_comparison_exp
  first_name: String_comparison_exp
  id: String_comparison_exp
  last_name: String_comparison_exp
}

"""
unique or primary key constraints on table "boat.users"
"""
enum users_constraint {
  """unique or primary key constraint"""
  app_users_email_key

  """unique or primary key constraint"""
  app_users_pkey
}

"""
input type for inserting data into table "boat.users"
"""
input users_insert_input {
  availability_groups: availability_groups_arr_rel_insert_input
  email: String
  first_name: String
  id: String
  last_name: String
}

"""aggregate max on columns"""
type users_max_fields {
  email: String
  first_name: String
  id: String
  last_name: String
}

"""
order by max() on columns of table "boat.users"
"""
input users_max_order_by {
  email: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  email: String
  first_name: String
  id: String
  last_name: String
}

"""
order by min() on columns of table "boat.users"
"""
input users_min_order_by {
  email: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
}

"""
response of any mutation on the table "boat.users"
"""
type users_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "boat.users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!
  on_conflict: users_on_conflict
}

"""
on conflict condition type for table "boat.users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]!
  where: users_bool_exp
}

"""
ordering options when selecting data from "boat.users"
"""
input users_order_by {
  availability_groups_aggregate: availability_groups_aggregate_order_by
  email: order_by
  first_name: order_by
  id: order_by
  last_name: order_by
}

"""
primary key columns input for table: "boat.users"
"""
input users_pk_columns_input {
  id: String!
}

"""
select columns of table "boat.users"
"""
enum users_select_column {
  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  last_name
}

"""
input type for updating data in table "boat.users"
"""
input users_set_input {
  email: String
  first_name: String
  id: String
  last_name: String
}

"""
update columns of table "boat.users"
"""
enum users_update_column {
  """column name"""
  email

  """column name"""
  first_name

  """column name"""
  id

  """column name"""
  last_name
}

"""
columns and relationships of "boat.vehicles"
"""
type vehicles {
  capacity: Int

  """An object relationship"""
  city: city
  city_id: String
  colour: String
  created_at: timestamptz
  id: String!
  insurance: String
  maintenence: String
  make_model: String
  name: String!
  office: String!
  ownership: String
  plate_number: String
  samsara_id: String
  samsara_viewer_url: String
  updated_at: timestamptz
  vin_number: String
  year: Int
}

"""
aggregated selection of "boat.vehicles"
"""
type vehicles_aggregate {
  aggregate: vehicles_aggregate_fields
  nodes: [vehicles!]!
}

"""
aggregate fields of "boat.vehicles"
"""
type vehicles_aggregate_fields {
  avg: vehicles_avg_fields
  count(columns: [vehicles_select_column!], distinct: Boolean): Int
  max: vehicles_max_fields
  min: vehicles_min_fields
  stddev: vehicles_stddev_fields
  stddev_pop: vehicles_stddev_pop_fields
  stddev_samp: vehicles_stddev_samp_fields
  sum: vehicles_sum_fields
  var_pop: vehicles_var_pop_fields
  var_samp: vehicles_var_samp_fields
  variance: vehicles_variance_fields
}

"""
order by aggregate values of table "boat.vehicles"
"""
input vehicles_aggregate_order_by {
  avg: vehicles_avg_order_by
  count: order_by
  max: vehicles_max_order_by
  min: vehicles_min_order_by
  stddev: vehicles_stddev_order_by
  stddev_pop: vehicles_stddev_pop_order_by
  stddev_samp: vehicles_stddev_samp_order_by
  sum: vehicles_sum_order_by
  var_pop: vehicles_var_pop_order_by
  var_samp: vehicles_var_samp_order_by
  variance: vehicles_variance_order_by
}

"""
input type for inserting array relation for remote table "boat.vehicles"
"""
input vehicles_arr_rel_insert_input {
  data: [vehicles_insert_input!]!
  on_conflict: vehicles_on_conflict
}

"""aggregate avg on columns"""
type vehicles_avg_fields {
  capacity: Float
  year: Float
}

"""
order by avg() on columns of table "boat.vehicles"
"""
input vehicles_avg_order_by {
  capacity: order_by
  year: order_by
}

"""
Boolean expression to filter rows from the table "boat.vehicles". All fields are combined with a logical 'AND'.
"""
input vehicles_bool_exp {
  _and: [vehicles_bool_exp]
  _not: vehicles_bool_exp
  _or: [vehicles_bool_exp]
  capacity: Int_comparison_exp
  city: city_bool_exp
  city_id: String_comparison_exp
  colour: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  insurance: String_comparison_exp
  maintenence: String_comparison_exp
  make_model: String_comparison_exp
  name: String_comparison_exp
  office: String_comparison_exp
  ownership: String_comparison_exp
  plate_number: String_comparison_exp
  samsara_id: String_comparison_exp
  samsara_viewer_url: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  vin_number: String_comparison_exp
  year: Int_comparison_exp
}

"""
unique or primary key constraints on table "boat.vehicles"
"""
enum vehicles_constraint {
  """unique or primary key constraint"""
  tables_test_pkey

  """unique or primary key constraint"""
  vehicles_id_key
}

"""
input type for incrementing integer column in table "boat.vehicles"
"""
input vehicles_inc_input {
  capacity: Int
  year: Int
}

"""
input type for inserting data into table "boat.vehicles"
"""
input vehicles_insert_input {
  capacity: Int
  city: city_obj_rel_insert_input
  city_id: String
  colour: String
  created_at: timestamptz
  id: String
  insurance: String
  maintenence: String
  make_model: String
  name: String
  office: String
  ownership: String
  plate_number: String
  samsara_id: String
  samsara_viewer_url: String
  updated_at: timestamptz
  vin_number: String
  year: Int
}

"""aggregate max on columns"""
type vehicles_max_fields {
  capacity: Int
  city_id: String
  colour: String
  created_at: timestamptz
  id: String
  insurance: String
  maintenence: String
  make_model: String
  name: String
  office: String
  ownership: String
  plate_number: String
  samsara_id: String
  samsara_viewer_url: String
  updated_at: timestamptz
  vin_number: String
  year: Int
}

"""
order by max() on columns of table "boat.vehicles"
"""
input vehicles_max_order_by {
  capacity: order_by
  city_id: order_by
  colour: order_by
  created_at: order_by
  id: order_by
  insurance: order_by
  maintenence: order_by
  make_model: order_by
  name: order_by
  office: order_by
  ownership: order_by
  plate_number: order_by
  samsara_id: order_by
  samsara_viewer_url: order_by
  updated_at: order_by
  vin_number: order_by
  year: order_by
}

"""aggregate min on columns"""
type vehicles_min_fields {
  capacity: Int
  city_id: String
  colour: String
  created_at: timestamptz
  id: String
  insurance: String
  maintenence: String
  make_model: String
  name: String
  office: String
  ownership: String
  plate_number: String
  samsara_id: String
  samsara_viewer_url: String
  updated_at: timestamptz
  vin_number: String
  year: Int
}

"""
order by min() on columns of table "boat.vehicles"
"""
input vehicles_min_order_by {
  capacity: order_by
  city_id: order_by
  colour: order_by
  created_at: order_by
  id: order_by
  insurance: order_by
  maintenence: order_by
  make_model: order_by
  name: order_by
  office: order_by
  ownership: order_by
  plate_number: order_by
  samsara_id: order_by
  samsara_viewer_url: order_by
  updated_at: order_by
  vin_number: order_by
  year: order_by
}

"""
response of any mutation on the table "boat.vehicles"
"""
type vehicles_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [vehicles!]!
}

"""
input type for inserting object relation for remote table "boat.vehicles"
"""
input vehicles_obj_rel_insert_input {
  data: vehicles_insert_input!
  on_conflict: vehicles_on_conflict
}

"""
on conflict condition type for table "boat.vehicles"
"""
input vehicles_on_conflict {
  constraint: vehicles_constraint!
  update_columns: [vehicles_update_column!]!
  where: vehicles_bool_exp
}

"""
ordering options when selecting data from "boat.vehicles"
"""
input vehicles_order_by {
  capacity: order_by
  city: city_order_by
  city_id: order_by
  colour: order_by
  created_at: order_by
  id: order_by
  insurance: order_by
  maintenence: order_by
  make_model: order_by
  name: order_by
  office: order_by
  ownership: order_by
  plate_number: order_by
  samsara_id: order_by
  samsara_viewer_url: order_by
  updated_at: order_by
  vin_number: order_by
  year: order_by
}

"""
primary key columns input for table: "boat.vehicles"
"""
input vehicles_pk_columns_input {
  id: String!
}

"""
select columns of table "boat.vehicles"
"""
enum vehicles_select_column {
  """column name"""
  capacity

  """column name"""
  city_id

  """column name"""
  colour

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  insurance

  """column name"""
  maintenence

  """column name"""
  make_model

  """column name"""
  name

  """column name"""
  office

  """column name"""
  ownership

  """column name"""
  plate_number

  """column name"""
  samsara_id

  """column name"""
  samsara_viewer_url

  """column name"""
  updated_at

  """column name"""
  vin_number

  """column name"""
  year
}

"""
input type for updating data in table "boat.vehicles"
"""
input vehicles_set_input {
  capacity: Int
  city_id: String
  colour: String
  created_at: timestamptz
  id: String
  insurance: String
  maintenence: String
  make_model: String
  name: String
  office: String
  ownership: String
  plate_number: String
  samsara_id: String
  samsara_viewer_url: String
  updated_at: timestamptz
  vin_number: String
  year: Int
}

"""aggregate stddev on columns"""
type vehicles_stddev_fields {
  capacity: Float
  year: Float
}

"""
order by stddev() on columns of table "boat.vehicles"
"""
input vehicles_stddev_order_by {
  capacity: order_by
  year: order_by
}

"""aggregate stddev_pop on columns"""
type vehicles_stddev_pop_fields {
  capacity: Float
  year: Float
}

"""
order by stddev_pop() on columns of table "boat.vehicles"
"""
input vehicles_stddev_pop_order_by {
  capacity: order_by
  year: order_by
}

"""aggregate stddev_samp on columns"""
type vehicles_stddev_samp_fields {
  capacity: Float
  year: Float
}

"""
order by stddev_samp() on columns of table "boat.vehicles"
"""
input vehicles_stddev_samp_order_by {
  capacity: order_by
  year: order_by
}

"""aggregate sum on columns"""
type vehicles_sum_fields {
  capacity: Int
  year: Int
}

"""
order by sum() on columns of table "boat.vehicles"
"""
input vehicles_sum_order_by {
  capacity: order_by
  year: order_by
}

"""
update columns of table "boat.vehicles"
"""
enum vehicles_update_column {
  """column name"""
  capacity

  """column name"""
  city_id

  """column name"""
  colour

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  insurance

  """column name"""
  maintenence

  """column name"""
  make_model

  """column name"""
  name

  """column name"""
  office

  """column name"""
  ownership

  """column name"""
  plate_number

  """column name"""
  samsara_id

  """column name"""
  samsara_viewer_url

  """column name"""
  updated_at

  """column name"""
  vin_number

  """column name"""
  year
}

"""aggregate var_pop on columns"""
type vehicles_var_pop_fields {
  capacity: Float
  year: Float
}

"""
order by var_pop() on columns of table "boat.vehicles"
"""
input vehicles_var_pop_order_by {
  capacity: order_by
  year: order_by
}

"""aggregate var_samp on columns"""
type vehicles_var_samp_fields {
  capacity: Float
  year: Float
}

"""
order by var_samp() on columns of table "boat.vehicles"
"""
input vehicles_var_samp_order_by {
  capacity: order_by
  year: order_by
}

"""aggregate variance on columns"""
type vehicles_variance_fields {
  capacity: Float
  year: Float
}

"""
order by variance() on columns of table "boat.vehicles"
"""
input vehicles_variance_order_by {
  capacity: order_by
  year: order_by
}

"""mutation root"""
type mutation_root {
  """
  perform the action: "actionName"
  """
  actionName(arg1: SampleInput!): SampleOutput

  """
  delete data from the table: "boat.agents"
  """
  delete_agents(
    """filter the rows which have to be deleted"""
    where: agents_bool_exp!
  ): agents_mutation_response

  """
  delete single row from the table: "boat.agents"
  """
  delete_agents_by_pk(id: String!): agents

  """
  delete data from the table: "boat.attractions"
  """
  delete_attractions(
    """filter the rows which have to be deleted"""
    where: attractions_bool_exp!
  ): attractions_mutation_response

  """
  delete single row from the table: "boat.attractions"
  """
  delete_attractions_by_pk(id: String!): attractions

  """
  delete data from the table: "boat.availabilities"
  """
  delete_availabilities(
    """filter the rows which have to be deleted"""
    where: availabilities_bool_exp!
  ): availabilities_mutation_response

  """
  delete single row from the table: "boat.availabilities"
  """
  delete_availabilities_by_pk(id: String!): availabilities

  """
  delete data from the table: "boat.availabilities_group"
  """
  delete_availabilities_group(
    """filter the rows which have to be deleted"""
    where: availabilities_group_bool_exp!
  ): availabilities_group_mutation_response

  """
  delete single row from the table: "boat.availabilities_group"
  """
  delete_availabilities_group_by_pk(id: String!): availabilities_group

  """
  delete data from the table: "boat.booking"
  """
  delete_booking(
    """filter the rows which have to be deleted"""
    where: booking_bool_exp!
  ): booking_mutation_response

  """
  delete single row from the table: "boat.booking"
  """
  delete_booking_by_pk(id: String!): booking

  """
  delete data from the table: "boat.city"
  """
  delete_city(
    """filter the rows which have to be deleted"""
    where: city_bool_exp!
  ): city_mutation_response

  """
  delete single row from the table: "boat.city"
  """
  delete_city_by_pk(id: String!): city

  """
  delete data from the table: "boat.customers"
  """
  delete_customers(
    """filter the rows which have to be deleted"""
    where: customers_bool_exp!
  ): customers_mutation_response

  """
  delete single row from the table: "boat.customers"
  """
  delete_customers_by_pk(id: String!): customers

  """
  delete data from the table: "boat.logs"
  """
  delete_logs(
    """filter the rows which have to be deleted"""
    where: logs_bool_exp!
  ): logs_mutation_response

  """
  delete single row from the table: "boat.logs"
  """
  delete_logs_by_pk(id: String!): logs

  """
  delete data from the table: "boat.message_correspondence"
  """
  delete_message_correspondence(
    """filter the rows which have to be deleted"""
    where: message_correspondence_bool_exp!
  ): message_correspondence_mutation_response

  """
  delete single row from the table: "boat.message_correspondence"
  """
  delete_message_correspondence_by_pk(id: String!): message_correspondence

  """
  delete data from the table: "boat.options"
  """
  delete_options(
    """filter the rows which have to be deleted"""
    where: options_bool_exp!
  ): options_mutation_response

  """
  delete single row from the table: "boat.options"
  """
  delete_options_by_pk(id: String!): options

  """
  delete data from the table: "boat.products"
  """
  delete_products(
    """filter the rows which have to be deleted"""
    where: products_bool_exp!
  ): products_mutation_response

  """
  delete data from the table: "boat.products_attractions"
  """
  delete_products_attractions(
    """filter the rows which have to be deleted"""
    where: products_attractions_bool_exp!
  ): products_attractions_mutation_response

  """
  delete single row from the table: "boat.products_attractions"
  """
  delete_products_attractions_by_pk(attraction_id: String!, product_id: String!): products_attractions

  """
  delete single row from the table: "boat.products"
  """
  delete_products_by_pk(id: String!): products

  """
  delete data from the table: "boat.products_view"
  """
  delete_products_view(
    """filter the rows which have to be deleted"""
    where: products_view_bool_exp!
  ): products_view_mutation_response

  """
  delete data from the table: "boat.resources"
  """
  delete_resources(
    """filter the rows which have to be deleted"""
    where: resources_bool_exp!
  ): resources_mutation_response

  """
  delete single row from the table: "boat.resources"
  """
  delete_resources_by_pk(id: String!): resources

  """
  delete data from the table: "boat.sessions"
  """
  delete_sessions(
    """filter the rows which have to be deleted"""
    where: sessions_bool_exp!
  ): sessions_mutation_response

  """
  delete single row from the table: "boat.sessions"
  """
  delete_sessions_by_pk(id: String!): sessions

  """
  delete data from the table: "boat.subtasks"
  """
  delete_subtasks(
    """filter the rows which have to be deleted"""
    where: subtasks_bool_exp!
  ): subtasks_mutation_response

  """
  delete single row from the table: "boat.subtasks"
  """
  delete_subtasks_by_pk(id: String!): subtasks

  """
  delete data from the table: "boat.test_table"
  """
  delete_test_table(
    """filter the rows which have to be deleted"""
    where: test_table_bool_exp!
  ): test_table_mutation_response

  """
  delete single row from the table: "boat.test_table"
  """
  delete_test_table_by_pk(id: String!): test_table

  """
  delete data from the table: "boat.transactions"
  """
  delete_transactions(
    """filter the rows which have to be deleted"""
    where: transactions_bool_exp!
  ): transactions_mutation_response

  """
  delete single row from the table: "boat.transactions"
  """
  delete_transactions_by_pk(stripe_id: String!): transactions

  """
  delete data from the table: "boat.units"
  """
  delete_units(
    """filter the rows which have to be deleted"""
    where: units_bool_exp!
  ): units_mutation_response

  """
  delete single row from the table: "boat.units"
  """
  delete_units_by_pk(id: String!): units

  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: String!): user

  """
  delete data from the table: "boat.users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "boat.users"
  """
  delete_users_by_pk(id: String!): users

  """
  delete data from the table: "boat.vehicles"
  """
  delete_vehicles(
    """filter the rows which have to be deleted"""
    where: vehicles_bool_exp!
  ): vehicles_mutation_response

  """
  delete single row from the table: "boat.vehicles"
  """
  delete_vehicles_by_pk(id: String!): vehicles

  """
  insert data into the table: "boat.agents"
  """
  insert_agents(
    """the rows to be inserted"""
    objects: [agents_insert_input!]!

    """on conflict condition"""
    on_conflict: agents_on_conflict
  ): agents_mutation_response

  """
  insert a single row into the table: "boat.agents"
  """
  insert_agents_one(
    """the row to be inserted"""
    object: agents_insert_input!

    """on conflict condition"""
    on_conflict: agents_on_conflict
  ): agents

  """
  insert data into the table: "boat.attractions"
  """
  insert_attractions(
    """the rows to be inserted"""
    objects: [attractions_insert_input!]!

    """on conflict condition"""
    on_conflict: attractions_on_conflict
  ): attractions_mutation_response

  """
  insert a single row into the table: "boat.attractions"
  """
  insert_attractions_one(
    """the row to be inserted"""
    object: attractions_insert_input!

    """on conflict condition"""
    on_conflict: attractions_on_conflict
  ): attractions

  """
  insert data into the table: "boat.availabilities"
  """
  insert_availabilities(
    """the rows to be inserted"""
    objects: [availabilities_insert_input!]!

    """on conflict condition"""
    on_conflict: availabilities_on_conflict
  ): availabilities_mutation_response

  """
  insert data into the table: "boat.availabilities_group"
  """
  insert_availabilities_group(
    """the rows to be inserted"""
    objects: [availabilities_group_insert_input!]!

    """on conflict condition"""
    on_conflict: availabilities_group_on_conflict
  ): availabilities_group_mutation_response

  """
  insert a single row into the table: "boat.availabilities_group"
  """
  insert_availabilities_group_one(
    """the row to be inserted"""
    object: availabilities_group_insert_input!

    """on conflict condition"""
    on_conflict: availabilities_group_on_conflict
  ): availabilities_group

  """
  insert a single row into the table: "boat.availabilities"
  """
  insert_availabilities_one(
    """the row to be inserted"""
    object: availabilities_insert_input!

    """on conflict condition"""
    on_conflict: availabilities_on_conflict
  ): availabilities

  """
  insert data into the table: "boat.booking"
  """
  insert_booking(
    """the rows to be inserted"""
    objects: [booking_insert_input!]!

    """on conflict condition"""
    on_conflict: booking_on_conflict
  ): booking_mutation_response

  """
  insert a single row into the table: "boat.booking"
  """
  insert_booking_one(
    """the row to be inserted"""
    object: booking_insert_input!

    """on conflict condition"""
    on_conflict: booking_on_conflict
  ): booking

  """
  insert data into the table: "boat.city"
  """
  insert_city(
    """the rows to be inserted"""
    objects: [city_insert_input!]!

    """on conflict condition"""
    on_conflict: city_on_conflict
  ): city_mutation_response

  """
  insert a single row into the table: "boat.city"
  """
  insert_city_one(
    """the row to be inserted"""
    object: city_insert_input!

    """on conflict condition"""
    on_conflict: city_on_conflict
  ): city

  """
  insert data into the table: "boat.customers"
  """
  insert_customers(
    """the rows to be inserted"""
    objects: [customers_insert_input!]!

    """on conflict condition"""
    on_conflict: customers_on_conflict
  ): customers_mutation_response

  """
  insert a single row into the table: "boat.customers"
  """
  insert_customers_one(
    """the row to be inserted"""
    object: customers_insert_input!

    """on conflict condition"""
    on_conflict: customers_on_conflict
  ): customers

  """
  insert data into the table: "boat.logs"
  """
  insert_logs(
    """the rows to be inserted"""
    objects: [logs_insert_input!]!

    """on conflict condition"""
    on_conflict: logs_on_conflict
  ): logs_mutation_response

  """
  insert a single row into the table: "boat.logs"
  """
  insert_logs_one(
    """the row to be inserted"""
    object: logs_insert_input!

    """on conflict condition"""
    on_conflict: logs_on_conflict
  ): logs

  """
  insert data into the table: "boat.message_correspondence"
  """
  insert_message_correspondence(
    """the rows to be inserted"""
    objects: [message_correspondence_insert_input!]!

    """on conflict condition"""
    on_conflict: message_correspondence_on_conflict
  ): message_correspondence_mutation_response

  """
  insert a single row into the table: "boat.message_correspondence"
  """
  insert_message_correspondence_one(
    """the row to be inserted"""
    object: message_correspondence_insert_input!

    """on conflict condition"""
    on_conflict: message_correspondence_on_conflict
  ): message_correspondence

  """
  insert data into the table: "boat.options"
  """
  insert_options(
    """the rows to be inserted"""
    objects: [options_insert_input!]!

    """on conflict condition"""
    on_conflict: options_on_conflict
  ): options_mutation_response

  """
  insert a single row into the table: "boat.options"
  """
  insert_options_one(
    """the row to be inserted"""
    object: options_insert_input!

    """on conflict condition"""
    on_conflict: options_on_conflict
  ): options

  """
  insert data into the table: "boat.products"
  """
  insert_products(
    """the rows to be inserted"""
    objects: [products_insert_input!]!

    """on conflict condition"""
    on_conflict: products_on_conflict
  ): products_mutation_response

  """
  insert data into the table: "boat.products_attractions"
  """
  insert_products_attractions(
    """the rows to be inserted"""
    objects: [products_attractions_insert_input!]!

    """on conflict condition"""
    on_conflict: products_attractions_on_conflict
  ): products_attractions_mutation_response

  """
  insert a single row into the table: "boat.products_attractions"
  """
  insert_products_attractions_one(
    """the row to be inserted"""
    object: products_attractions_insert_input!

    """on conflict condition"""
    on_conflict: products_attractions_on_conflict
  ): products_attractions

  """
  insert a single row into the table: "boat.products"
  """
  insert_products_one(
    """the row to be inserted"""
    object: products_insert_input!

    """on conflict condition"""
    on_conflict: products_on_conflict
  ): products

  """
  insert data into the table: "boat.products_view"
  """
  insert_products_view(
    """the rows to be inserted"""
    objects: [products_view_insert_input!]!
  ): products_view_mutation_response

  """
  insert a single row into the table: "boat.products_view"
  """
  insert_products_view_one(
    """the row to be inserted"""
    object: products_view_insert_input!
  ): products_view

  """
  insert data into the table: "boat.resources"
  """
  insert_resources(
    """the rows to be inserted"""
    objects: [resources_insert_input!]!

    """on conflict condition"""
    on_conflict: resources_on_conflict
  ): resources_mutation_response

  """
  insert a single row into the table: "boat.resources"
  """
  insert_resources_one(
    """the row to be inserted"""
    object: resources_insert_input!

    """on conflict condition"""
    on_conflict: resources_on_conflict
  ): resources

  """
  insert data into the table: "boat.sessions"
  """
  insert_sessions(
    """the rows to be inserted"""
    objects: [sessions_insert_input!]!

    """on conflict condition"""
    on_conflict: sessions_on_conflict
  ): sessions_mutation_response

  """
  insert a single row into the table: "boat.sessions"
  """
  insert_sessions_one(
    """the row to be inserted"""
    object: sessions_insert_input!

    """on conflict condition"""
    on_conflict: sessions_on_conflict
  ): sessions

  """
  insert data into the table: "boat.subtasks"
  """
  insert_subtasks(
    """the rows to be inserted"""
    objects: [subtasks_insert_input!]!

    """on conflict condition"""
    on_conflict: subtasks_on_conflict
  ): subtasks_mutation_response

  """
  insert a single row into the table: "boat.subtasks"
  """
  insert_subtasks_one(
    """the row to be inserted"""
    object: subtasks_insert_input!

    """on conflict condition"""
    on_conflict: subtasks_on_conflict
  ): subtasks

  """
  insert data into the table: "boat.test_table"
  """
  insert_test_table(
    """the rows to be inserted"""
    objects: [test_table_insert_input!]!

    """on conflict condition"""
    on_conflict: test_table_on_conflict
  ): test_table_mutation_response

  """
  insert a single row into the table: "boat.test_table"
  """
  insert_test_table_one(
    """the row to be inserted"""
    object: test_table_insert_input!

    """on conflict condition"""
    on_conflict: test_table_on_conflict
  ): test_table

  """
  insert data into the table: "boat.transactions"
  """
  insert_transactions(
    """the rows to be inserted"""
    objects: [transactions_insert_input!]!

    """on conflict condition"""
    on_conflict: transactions_on_conflict
  ): transactions_mutation_response

  """
  insert a single row into the table: "boat.transactions"
  """
  insert_transactions_one(
    """the row to be inserted"""
    object: transactions_insert_input!

    """on conflict condition"""
    on_conflict: transactions_on_conflict
  ): transactions

  """
  insert data into the table: "boat.units"
  """
  insert_units(
    """the rows to be inserted"""
    objects: [units_insert_input!]!

    """on conflict condition"""
    on_conflict: units_on_conflict
  ): units_mutation_response

  """
  insert a single row into the table: "boat.units"
  """
  insert_units_one(
    """the row to be inserted"""
    object: units_insert_input!

    """on conflict condition"""
    on_conflict: units_on_conflict
  ): units

  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """on conflict condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!

    """on conflict condition"""
    on_conflict: user_on_conflict
  ): user

  """
  insert data into the table: "boat.users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "boat.users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "boat.vehicles"
  """
  insert_vehicles(
    """the rows to be inserted"""
    objects: [vehicles_insert_input!]!

    """on conflict condition"""
    on_conflict: vehicles_on_conflict
  ): vehicles_mutation_response

  """
  insert a single row into the table: "boat.vehicles"
  """
  insert_vehicles_one(
    """the row to be inserted"""
    object: vehicles_insert_input!

    """on conflict condition"""
    on_conflict: vehicles_on_conflict
  ): vehicles

  """
  update data of the table: "boat.agents"
  """
  update_agents(
    """increments the integer columns with given value of the filtered values"""
    _inc: agents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agents_set_input

    """filter the rows which have to be updated"""
    where: agents_bool_exp!
  ): agents_mutation_response

  """
  update single row of the table: "boat.agents"
  """
  update_agents_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: agents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: agents_set_input
    pk_columns: agents_pk_columns_input!
  ): agents

  """
  update data of the table: "boat.attractions"
  """
  update_attractions(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: attractions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: attractions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: attractions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: attractions_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: attractions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: attractions_set_input

    """filter the rows which have to be updated"""
    where: attractions_bool_exp!
  ): attractions_mutation_response

  """
  update single row of the table: "boat.attractions"
  """
  update_attractions_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: attractions_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: attractions_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: attractions_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: attractions_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: attractions_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: attractions_set_input
    pk_columns: attractions_pk_columns_input!
  ): attractions

  """
  update data of the table: "boat.availabilities"
  """
  update_availabilities(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: availabilities_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: availabilities_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: availabilities_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: availabilities_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: availabilities_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: availabilities_set_input

    """filter the rows which have to be updated"""
    where: availabilities_bool_exp!
  ): availabilities_mutation_response

  """
  update single row of the table: "boat.availabilities"
  """
  update_availabilities_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: availabilities_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: availabilities_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: availabilities_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: availabilities_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: availabilities_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: availabilities_set_input
    pk_columns: availabilities_pk_columns_input!
  ): availabilities

  """
  update data of the table: "boat.availabilities_group"
  """
  update_availabilities_group(
    """sets the columns of the filtered rows to the given values"""
    _set: availabilities_group_set_input

    """filter the rows which have to be updated"""
    where: availabilities_group_bool_exp!
  ): availabilities_group_mutation_response

  """
  update single row of the table: "boat.availabilities_group"
  """
  update_availabilities_group_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: availabilities_group_set_input
    pk_columns: availabilities_group_pk_columns_input!
  ): availabilities_group

  """
  update data of the table: "boat.booking"
  """
  update_booking(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: booking_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: booking_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: booking_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: booking_delete_key_input

    """increments the integer columns with given value of the filtered values"""
    _inc: booking_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: booking_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_set_input

    """filter the rows which have to be updated"""
    where: booking_bool_exp!
  ): booking_mutation_response

  """
  update single row of the table: "boat.booking"
  """
  update_booking_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: booking_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: booking_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: booking_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: booking_delete_key_input

    """increments the integer columns with given value of the filtered values"""
    _inc: booking_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: booking_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: booking_set_input
    pk_columns: booking_pk_columns_input!
  ): booking

  """
  update data of the table: "boat.city"
  """
  update_city(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: city_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: city_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: city_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: city_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: city_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: city_set_input

    """filter the rows which have to be updated"""
    where: city_bool_exp!
  ): city_mutation_response

  """
  update single row of the table: "boat.city"
  """
  update_city_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: city_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: city_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: city_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: city_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: city_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: city_set_input
    pk_columns: city_pk_columns_input!
  ): city

  """
  update data of the table: "boat.customers"
  """
  update_customers(
    """sets the columns of the filtered rows to the given values"""
    _set: customers_set_input

    """filter the rows which have to be updated"""
    where: customers_bool_exp!
  ): customers_mutation_response

  """
  update single row of the table: "boat.customers"
  """
  update_customers_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: customers_set_input
    pk_columns: customers_pk_columns_input!
  ): customers

  """
  update data of the table: "boat.logs"
  """
  update_logs(
    """sets the columns of the filtered rows to the given values"""
    _set: logs_set_input

    """filter the rows which have to be updated"""
    where: logs_bool_exp!
  ): logs_mutation_response

  """
  update single row of the table: "boat.logs"
  """
  update_logs_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: logs_set_input
    pk_columns: logs_pk_columns_input!
  ): logs

  """
  update data of the table: "boat.message_correspondence"
  """
  update_message_correspondence(
    """sets the columns of the filtered rows to the given values"""
    _set: message_correspondence_set_input

    """filter the rows which have to be updated"""
    where: message_correspondence_bool_exp!
  ): message_correspondence_mutation_response

  """
  update single row of the table: "boat.message_correspondence"
  """
  update_message_correspondence_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: message_correspondence_set_input
    pk_columns: message_correspondence_pk_columns_input!
  ): message_correspondence

  """
  update data of the table: "boat.options"
  """
  update_options(
    """sets the columns of the filtered rows to the given values"""
    _set: options_set_input

    """filter the rows which have to be updated"""
    where: options_bool_exp!
  ): options_mutation_response

  """
  update single row of the table: "boat.options"
  """
  update_options_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: options_set_input
    pk_columns: options_pk_columns_input!
  ): options

  """
  update data of the table: "boat.products"
  """
  update_products(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: products_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: products_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: products_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: products_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: products_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: products_set_input

    """filter the rows which have to be updated"""
    where: products_bool_exp!
  ): products_mutation_response

  """
  update data of the table: "boat.products_attractions"
  """
  update_products_attractions(
    """sets the columns of the filtered rows to the given values"""
    _set: products_attractions_set_input

    """filter the rows which have to be updated"""
    where: products_attractions_bool_exp!
  ): products_attractions_mutation_response

  """
  update single row of the table: "boat.products_attractions"
  """
  update_products_attractions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: products_attractions_set_input
    pk_columns: products_attractions_pk_columns_input!
  ): products_attractions

  """
  update single row of the table: "boat.products"
  """
  update_products_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: products_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: products_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: products_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: products_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: products_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: products_set_input
    pk_columns: products_pk_columns_input!
  ): products

  """
  update data of the table: "boat.products_view"
  """
  update_products_view(
    """increments the integer columns with given value of the filtered values"""
    _inc: products_view_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: products_view_set_input

    """filter the rows which have to be updated"""
    where: products_view_bool_exp!
  ): products_view_mutation_response

  """
  update data of the table: "boat.resources"
  """
  update_resources(
    """increments the integer columns with given value of the filtered values"""
    _inc: resources_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: resources_set_input

    """filter the rows which have to be updated"""
    where: resources_bool_exp!
  ): resources_mutation_response

  """
  update single row of the table: "boat.resources"
  """
  update_resources_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: resources_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: resources_set_input
    pk_columns: resources_pk_columns_input!
  ): resources

  """
  update data of the table: "boat.sessions"
  """
  update_sessions(
    """sets the columns of the filtered rows to the given values"""
    _set: sessions_set_input

    """filter the rows which have to be updated"""
    where: sessions_bool_exp!
  ): sessions_mutation_response

  """
  update single row of the table: "boat.sessions"
  """
  update_sessions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: sessions_set_input
    pk_columns: sessions_pk_columns_input!
  ): sessions

  """
  update data of the table: "boat.subtasks"
  """
  update_subtasks(
    """sets the columns of the filtered rows to the given values"""
    _set: subtasks_set_input

    """filter the rows which have to be updated"""
    where: subtasks_bool_exp!
  ): subtasks_mutation_response

  """
  update single row of the table: "boat.subtasks"
  """
  update_subtasks_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: subtasks_set_input
    pk_columns: subtasks_pk_columns_input!
  ): subtasks

  """
  update data of the table: "boat.test_table"
  """
  update_test_table(
    """sets the columns of the filtered rows to the given values"""
    _set: test_table_set_input

    """filter the rows which have to be updated"""
    where: test_table_bool_exp!
  ): test_table_mutation_response

  """
  update single row of the table: "boat.test_table"
  """
  update_test_table_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: test_table_set_input
    pk_columns: test_table_pk_columns_input!
  ): test_table

  """
  update data of the table: "boat.transactions"
  """
  update_transactions(
    """sets the columns of the filtered rows to the given values"""
    _set: transactions_set_input

    """filter the rows which have to be updated"""
    where: transactions_bool_exp!
  ): transactions_mutation_response

  """
  update single row of the table: "boat.transactions"
  """
  update_transactions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: transactions_set_input
    pk_columns: transactions_pk_columns_input!
  ): transactions

  """
  update data of the table: "boat.units"
  """
  update_units(
    """sets the columns of the filtered rows to the given values"""
    _set: units_set_input

    """filter the rows which have to be updated"""
    where: units_bool_exp!
  ): units_mutation_response

  """
  update single row of the table: "boat.units"
  """
  update_units_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: units_set_input
    pk_columns: units_pk_columns_input!
  ): units

  """
  update data of the table: "user"
  """
  update_user(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update data of the table: "boat.users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "boat.users"
  """
  update_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update data of the table: "boat.vehicles"
  """
  update_vehicles(
    """increments the integer columns with given value of the filtered values"""
    _inc: vehicles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: vehicles_set_input

    """filter the rows which have to be updated"""
    where: vehicles_bool_exp!
  ): vehicles_mutation_response

  """
  update single row of the table: "boat.vehicles"
  """
  update_vehicles_by_pk(
    """increments the integer columns with given value of the filtered values"""
    _inc: vehicles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: vehicles_set_input
    pk_columns: vehicles_pk_columns_input!
  ): vehicles

  """
  fetch data from the table: "boat.agents"
  """
  agents(
    """distinct select on columns"""
    distinct_on: [agents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agents_order_by!]

    """filter the rows returned"""
    where: agents_bool_exp
  ): [agents!]!

  """
  fetch aggregated fields from the table: "boat.agents"
  """
  agents_aggregate(
    """distinct select on columns"""
    distinct_on: [agents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agents_order_by!]

    """filter the rows returned"""
    where: agents_bool_exp
  ): agents_aggregate!

  """fetch data from the table: "boat.agents" using primary key columns"""
  agents_by_pk(id: String!): agents

  """
  fetch data from the table: "boat.attractions"
  """
  attractions(
    """distinct select on columns"""
    distinct_on: [attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attractions_order_by!]

    """filter the rows returned"""
    where: attractions_bool_exp
  ): [attractions!]!

  """
  fetch aggregated fields from the table: "boat.attractions"
  """
  attractions_aggregate(
    """distinct select on columns"""
    distinct_on: [attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attractions_order_by!]

    """filter the rows returned"""
    where: attractions_bool_exp
  ): attractions_aggregate!

  """
  fetch data from the table: "boat.attractions" using primary key columns
  """
  attractions_by_pk(id: String!): attractions

  """
  fetch data from the table: "boat.availabilities"
  """
  availabilities(
    """distinct select on columns"""
    distinct_on: [availabilities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_order_by!]

    """filter the rows returned"""
    where: availabilities_bool_exp
  ): [availabilities!]!

  """
  fetch aggregated fields from the table: "boat.availabilities"
  """
  availabilities_aggregate(
    """distinct select on columns"""
    distinct_on: [availabilities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_order_by!]

    """filter the rows returned"""
    where: availabilities_bool_exp
  ): availabilities_aggregate!

  """
  fetch data from the table: "boat.availabilities" using primary key columns
  """
  availabilities_by_pk(id: String!): availabilities

  """
  fetch data from the table: "boat.availabilities_group"
  """
  availabilities_group(
    """distinct select on columns"""
    distinct_on: [availabilities_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_group_order_by!]

    """filter the rows returned"""
    where: availabilities_group_bool_exp
  ): [availabilities_group!]!

  """
  fetch aggregated fields from the table: "boat.availabilities_group"
  """
  availabilities_group_aggregate(
    """distinct select on columns"""
    distinct_on: [availabilities_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_group_order_by!]

    """filter the rows returned"""
    where: availabilities_group_bool_exp
  ): availabilities_group_aggregate!

  """
  fetch data from the table: "boat.availabilities_group" using primary key columns
  """
  availabilities_group_by_pk(id: String!): availabilities_group

  """
  fetch data from the table: "boat.availabilities_view"
  """
  availabilities_view(
    """distinct select on columns"""
    distinct_on: [availabilities_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_view_order_by!]

    """filter the rows returned"""
    where: availabilities_view_bool_exp
  ): [availabilities_view!]!

  """
  fetch aggregated fields from the table: "boat.availabilities_view"
  """
  availabilities_view_aggregate(
    """distinct select on columns"""
    distinct_on: [availabilities_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_view_order_by!]

    """filter the rows returned"""
    where: availabilities_view_bool_exp
  ): availabilities_view_aggregate!

  """
  fetch data from the table: "boat.booking"
  """
  booking(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """
  fetch aggregated fields from the table: "boat.booking"
  """
  booking_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!

  """fetch data from the table: "boat.booking" using primary key columns"""
  booking_by_pk(id: String!): booking

  """
  fetch data from the table: "boat.city"
  """
  city(
    """distinct select on columns"""
    distinct_on: [city_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [city_order_by!]

    """filter the rows returned"""
    where: city_bool_exp
  ): [city!]!

  """
  fetch aggregated fields from the table: "boat.city"
  """
  city_aggregate(
    """distinct select on columns"""
    distinct_on: [city_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [city_order_by!]

    """filter the rows returned"""
    where: city_bool_exp
  ): city_aggregate!

  """fetch data from the table: "boat.city" using primary key columns"""
  city_by_pk(id: String!): city

  """
  fetch data from the table: "boat.customers"
  """
  customers(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): [customers!]!

  """
  fetch aggregated fields from the table: "boat.customers"
  """
  customers_aggregate(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): customers_aggregate!

  """fetch data from the table: "boat.customers" using primary key columns"""
  customers_by_pk(id: String!): customers

  """
  fetch data from the table: "boat.logs"
  """
  logs(
    """distinct select on columns"""
    distinct_on: [logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [logs_order_by!]

    """filter the rows returned"""
    where: logs_bool_exp
  ): [logs!]!

  """
  fetch aggregated fields from the table: "boat.logs"
  """
  logs_aggregate(
    """distinct select on columns"""
    distinct_on: [logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [logs_order_by!]

    """filter the rows returned"""
    where: logs_bool_exp
  ): logs_aggregate!

  """fetch data from the table: "boat.logs" using primary key columns"""
  logs_by_pk(id: String!): logs

  """
  fetch data from the table: "boat.message_correspondence"
  """
  message_correspondence(
    """distinct select on columns"""
    distinct_on: [message_correspondence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_correspondence_order_by!]

    """filter the rows returned"""
    where: message_correspondence_bool_exp
  ): [message_correspondence!]!

  """
  fetch aggregated fields from the table: "boat.message_correspondence"
  """
  message_correspondence_aggregate(
    """distinct select on columns"""
    distinct_on: [message_correspondence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_correspondence_order_by!]

    """filter the rows returned"""
    where: message_correspondence_bool_exp
  ): message_correspondence_aggregate!

  """
  fetch data from the table: "boat.message_correspondence" using primary key columns
  """
  message_correspondence_by_pk(id: String!): message_correspondence

  """
  fetch data from the table: "boat.options"
  """
  options(
    """distinct select on columns"""
    distinct_on: [options_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [options_order_by!]

    """filter the rows returned"""
    where: options_bool_exp
  ): [options!]!

  """
  fetch aggregated fields from the table: "boat.options"
  """
  options_aggregate(
    """distinct select on columns"""
    distinct_on: [options_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [options_order_by!]

    """filter the rows returned"""
    where: options_bool_exp
  ): options_aggregate!

  """fetch data from the table: "boat.options" using primary key columns"""
  options_by_pk(id: String!): options

  """
  fetch data from the table: "boat.options_view"
  """
  options_view(
    """distinct select on columns"""
    distinct_on: [options_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [options_view_order_by!]

    """filter the rows returned"""
    where: options_view_bool_exp
  ): [options_view!]!

  """
  fetch aggregated fields from the table: "boat.options_view"
  """
  options_view_aggregate(
    """distinct select on columns"""
    distinct_on: [options_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [options_view_order_by!]

    """filter the rows returned"""
    where: options_view_bool_exp
  ): options_view_aggregate!

  """
  fetch data from the table: "boat.products"
  """
  products(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """
  fetch aggregated fields from the table: "boat.products"
  """
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): products_aggregate!

  """
  fetch data from the table: "boat.products_attractions"
  """
  products_attractions(
    """distinct select on columns"""
    distinct_on: [products_attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_attractions_order_by!]

    """filter the rows returned"""
    where: products_attractions_bool_exp
  ): [products_attractions!]!

  """
  fetch aggregated fields from the table: "boat.products_attractions"
  """
  products_attractions_aggregate(
    """distinct select on columns"""
    distinct_on: [products_attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_attractions_order_by!]

    """filter the rows returned"""
    where: products_attractions_bool_exp
  ): products_attractions_aggregate!

  """
  fetch data from the table: "boat.products_attractions" using primary key columns
  """
  products_attractions_by_pk(attraction_id: String!, product_id: String!): products_attractions

  """fetch data from the table: "boat.products" using primary key columns"""
  products_by_pk(id: String!): products

  """
  fetch data from the table: "boat.products_view"
  """
  products_view(
    """distinct select on columns"""
    distinct_on: [products_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_view_order_by!]

    """filter the rows returned"""
    where: products_view_bool_exp
  ): [products_view!]!

  """
  fetch aggregated fields from the table: "boat.products_view"
  """
  products_view_aggregate(
    """distinct select on columns"""
    distinct_on: [products_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_view_order_by!]

    """filter the rows returned"""
    where: products_view_bool_exp
  ): products_view_aggregate!

  """
  fetch data from the table: "boat.resources"
  """
  resources(
    """distinct select on columns"""
    distinct_on: [resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resources_order_by!]

    """filter the rows returned"""
    where: resources_bool_exp
  ): [resources!]!

  """
  fetch aggregated fields from the table: "boat.resources"
  """
  resources_aggregate(
    """distinct select on columns"""
    distinct_on: [resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resources_order_by!]

    """filter the rows returned"""
    where: resources_bool_exp
  ): resources_aggregate!

  """fetch data from the table: "boat.resources" using primary key columns"""
  resources_by_pk(id: String!): resources

  """
  fetch data from the table: "boat.sessions"
  """
  sessions(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): [sessions!]!

  """
  fetch aggregated fields from the table: "boat.sessions"
  """
  sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): sessions_aggregate!

  """fetch data from the table: "boat.sessions" using primary key columns"""
  sessions_by_pk(id: String!): sessions

  """
  fetch data from the table: "boat.subtasks"
  """
  subtasks(
    """distinct select on columns"""
    distinct_on: [subtasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subtasks_order_by!]

    """filter the rows returned"""
    where: subtasks_bool_exp
  ): [subtasks!]!

  """
  fetch aggregated fields from the table: "boat.subtasks"
  """
  subtasks_aggregate(
    """distinct select on columns"""
    distinct_on: [subtasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subtasks_order_by!]

    """filter the rows returned"""
    where: subtasks_bool_exp
  ): subtasks_aggregate!

  """fetch data from the table: "boat.subtasks" using primary key columns"""
  subtasks_by_pk(id: String!): subtasks

  """
  fetch data from the table: "boat.test_table"
  """
  test_table(
    """distinct select on columns"""
    distinct_on: [test_table_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [test_table_order_by!]

    """filter the rows returned"""
    where: test_table_bool_exp
  ): [test_table!]!

  """
  fetch aggregated fields from the table: "boat.test_table"
  """
  test_table_aggregate(
    """distinct select on columns"""
    distinct_on: [test_table_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [test_table_order_by!]

    """filter the rows returned"""
    where: test_table_bool_exp
  ): test_table_aggregate!

  """fetch data from the table: "boat.test_table" using primary key columns"""
  test_table_by_pk(id: String!): test_table

  """
  fetch data from the table: "boat.transactions"
  """
  transactions(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): [transactions!]!

  """
  fetch aggregated fields from the table: "boat.transactions"
  """
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): transactions_aggregate!

  """
  fetch data from the table: "boat.transactions" using primary key columns
  """
  transactions_by_pk(stripe_id: String!): transactions

  """
  fetch data from the table: "boat.units"
  """
  units(
    """distinct select on columns"""
    distinct_on: [units_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [units_order_by!]

    """filter the rows returned"""
    where: units_bool_exp
  ): [units!]!

  """
  fetch aggregated fields from the table: "boat.units"
  """
  units_aggregate(
    """distinct select on columns"""
    distinct_on: [units_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [units_order_by!]

    """filter the rows returned"""
    where: units_bool_exp
  ): units_aggregate!

  """fetch data from the table: "boat.units" using primary key columns"""
  units_by_pk(id: String!): units

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: String!): user

  """
  fetch data from the table: "boat.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "boat.users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "boat.users" using primary key columns"""
  users_by_pk(id: String!): users

  """
  fetch data from the table: "boat.vehicles"
  """
  vehicles(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!

  """
  fetch aggregated fields from the table: "boat.vehicles"
  """
  vehicles_aggregate(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): vehicles_aggregate!

  """fetch data from the table: "boat.vehicles" using primary key columns"""
  vehicles_by_pk(id: String!): vehicles

  """
  fetch data from the table: "boat.agents"
  """
  agents(
    """distinct select on columns"""
    distinct_on: [agents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agents_order_by!]

    """filter the rows returned"""
    where: agents_bool_exp
  ): [agents!]!

  """
  fetch aggregated fields from the table: "boat.agents"
  """
  agents_aggregate(
    """distinct select on columns"""
    distinct_on: [agents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [agents_order_by!]

    """filter the rows returned"""
    where: agents_bool_exp
  ): agents_aggregate!

  """fetch data from the table: "boat.agents" using primary key columns"""
  agents_by_pk(id: String!): agents

  """
  fetch data from the table: "boat.attractions"
  """
  attractions(
    """distinct select on columns"""
    distinct_on: [attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attractions_order_by!]

    """filter the rows returned"""
    where: attractions_bool_exp
  ): [attractions!]!

  """
  fetch aggregated fields from the table: "boat.attractions"
  """
  attractions_aggregate(
    """distinct select on columns"""
    distinct_on: [attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attractions_order_by!]

    """filter the rows returned"""
    where: attractions_bool_exp
  ): attractions_aggregate!

  """
  fetch data from the table: "boat.attractions" using primary key columns
  """
  attractions_by_pk(id: String!): attractions

  """
  fetch data from the table: "boat.availabilities"
  """
  availabilities(
    """distinct select on columns"""
    distinct_on: [availabilities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_order_by!]

    """filter the rows returned"""
    where: availabilities_bool_exp
  ): [availabilities!]!

  """
  fetch aggregated fields from the table: "boat.availabilities"
  """
  availabilities_aggregate(
    """distinct select on columns"""
    distinct_on: [availabilities_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_order_by!]

    """filter the rows returned"""
    where: availabilities_bool_exp
  ): availabilities_aggregate!

  """
  fetch data from the table: "boat.availabilities" using primary key columns
  """
  availabilities_by_pk(id: String!): availabilities

  """
  fetch data from the table: "boat.availabilities_group"
  """
  availabilities_group(
    """distinct select on columns"""
    distinct_on: [availabilities_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_group_order_by!]

    """filter the rows returned"""
    where: availabilities_group_bool_exp
  ): [availabilities_group!]!

  """
  fetch aggregated fields from the table: "boat.availabilities_group"
  """
  availabilities_group_aggregate(
    """distinct select on columns"""
    distinct_on: [availabilities_group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_group_order_by!]

    """filter the rows returned"""
    where: availabilities_group_bool_exp
  ): availabilities_group_aggregate!

  """
  fetch data from the table: "boat.availabilities_group" using primary key columns
  """
  availabilities_group_by_pk(id: String!): availabilities_group

  """
  fetch data from the table: "boat.availabilities_view"
  """
  availabilities_view(
    """distinct select on columns"""
    distinct_on: [availabilities_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_view_order_by!]

    """filter the rows returned"""
    where: availabilities_view_bool_exp
  ): [availabilities_view!]!

  """
  fetch aggregated fields from the table: "boat.availabilities_view"
  """
  availabilities_view_aggregate(
    """distinct select on columns"""
    distinct_on: [availabilities_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [availabilities_view_order_by!]

    """filter the rows returned"""
    where: availabilities_view_bool_exp
  ): availabilities_view_aggregate!

  """
  fetch data from the table: "boat.booking"
  """
  booking(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): [booking!]!

  """
  fetch aggregated fields from the table: "boat.booking"
  """
  booking_aggregate(
    """distinct select on columns"""
    distinct_on: [booking_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [booking_order_by!]

    """filter the rows returned"""
    where: booking_bool_exp
  ): booking_aggregate!

  """fetch data from the table: "boat.booking" using primary key columns"""
  booking_by_pk(id: String!): booking

  """
  fetch data from the table: "boat.city"
  """
  city(
    """distinct select on columns"""
    distinct_on: [city_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [city_order_by!]

    """filter the rows returned"""
    where: city_bool_exp
  ): [city!]!

  """
  fetch aggregated fields from the table: "boat.city"
  """
  city_aggregate(
    """distinct select on columns"""
    distinct_on: [city_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [city_order_by!]

    """filter the rows returned"""
    where: city_bool_exp
  ): city_aggregate!

  """fetch data from the table: "boat.city" using primary key columns"""
  city_by_pk(id: String!): city

  """
  fetch data from the table: "boat.customers"
  """
  customers(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): [customers!]!

  """
  fetch aggregated fields from the table: "boat.customers"
  """
  customers_aggregate(
    """distinct select on columns"""
    distinct_on: [customers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [customers_order_by!]

    """filter the rows returned"""
    where: customers_bool_exp
  ): customers_aggregate!

  """fetch data from the table: "boat.customers" using primary key columns"""
  customers_by_pk(id: String!): customers

  """
  fetch data from the table: "boat.logs"
  """
  logs(
    """distinct select on columns"""
    distinct_on: [logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [logs_order_by!]

    """filter the rows returned"""
    where: logs_bool_exp
  ): [logs!]!

  """
  fetch aggregated fields from the table: "boat.logs"
  """
  logs_aggregate(
    """distinct select on columns"""
    distinct_on: [logs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [logs_order_by!]

    """filter the rows returned"""
    where: logs_bool_exp
  ): logs_aggregate!

  """fetch data from the table: "boat.logs" using primary key columns"""
  logs_by_pk(id: String!): logs

  """
  fetch data from the table: "boat.message_correspondence"
  """
  message_correspondence(
    """distinct select on columns"""
    distinct_on: [message_correspondence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_correspondence_order_by!]

    """filter the rows returned"""
    where: message_correspondence_bool_exp
  ): [message_correspondence!]!

  """
  fetch aggregated fields from the table: "boat.message_correspondence"
  """
  message_correspondence_aggregate(
    """distinct select on columns"""
    distinct_on: [message_correspondence_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [message_correspondence_order_by!]

    """filter the rows returned"""
    where: message_correspondence_bool_exp
  ): message_correspondence_aggregate!

  """
  fetch data from the table: "boat.message_correspondence" using primary key columns
  """
  message_correspondence_by_pk(id: String!): message_correspondence

  """
  fetch data from the table: "boat.options"
  """
  options(
    """distinct select on columns"""
    distinct_on: [options_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [options_order_by!]

    """filter the rows returned"""
    where: options_bool_exp
  ): [options!]!

  """
  fetch aggregated fields from the table: "boat.options"
  """
  options_aggregate(
    """distinct select on columns"""
    distinct_on: [options_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [options_order_by!]

    """filter the rows returned"""
    where: options_bool_exp
  ): options_aggregate!

  """fetch data from the table: "boat.options" using primary key columns"""
  options_by_pk(id: String!): options

  """
  fetch data from the table: "boat.options_view"
  """
  options_view(
    """distinct select on columns"""
    distinct_on: [options_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [options_view_order_by!]

    """filter the rows returned"""
    where: options_view_bool_exp
  ): [options_view!]!

  """
  fetch aggregated fields from the table: "boat.options_view"
  """
  options_view_aggregate(
    """distinct select on columns"""
    distinct_on: [options_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [options_view_order_by!]

    """filter the rows returned"""
    where: options_view_bool_exp
  ): options_view_aggregate!

  """
  fetch data from the table: "boat.products"
  """
  products(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): [products!]!

  """
  fetch aggregated fields from the table: "boat.products"
  """
  products_aggregate(
    """distinct select on columns"""
    distinct_on: [products_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_order_by!]

    """filter the rows returned"""
    where: products_bool_exp
  ): products_aggregate!

  """
  fetch data from the table: "boat.products_attractions"
  """
  products_attractions(
    """distinct select on columns"""
    distinct_on: [products_attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_attractions_order_by!]

    """filter the rows returned"""
    where: products_attractions_bool_exp
  ): [products_attractions!]!

  """
  fetch aggregated fields from the table: "boat.products_attractions"
  """
  products_attractions_aggregate(
    """distinct select on columns"""
    distinct_on: [products_attractions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_attractions_order_by!]

    """filter the rows returned"""
    where: products_attractions_bool_exp
  ): products_attractions_aggregate!

  """
  fetch data from the table: "boat.products_attractions" using primary key columns
  """
  products_attractions_by_pk(attraction_id: String!, product_id: String!): products_attractions

  """fetch data from the table: "boat.products" using primary key columns"""
  products_by_pk(id: String!): products

  """
  fetch data from the table: "boat.products_view"
  """
  products_view(
    """distinct select on columns"""
    distinct_on: [products_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_view_order_by!]

    """filter the rows returned"""
    where: products_view_bool_exp
  ): [products_view!]!

  """
  fetch aggregated fields from the table: "boat.products_view"
  """
  products_view_aggregate(
    """distinct select on columns"""
    distinct_on: [products_view_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [products_view_order_by!]

    """filter the rows returned"""
    where: products_view_bool_exp
  ): products_view_aggregate!

  """
  fetch data from the table: "boat.resources"
  """
  resources(
    """distinct select on columns"""
    distinct_on: [resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resources_order_by!]

    """filter the rows returned"""
    where: resources_bool_exp
  ): [resources!]!

  """
  fetch aggregated fields from the table: "boat.resources"
  """
  resources_aggregate(
    """distinct select on columns"""
    distinct_on: [resources_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resources_order_by!]

    """filter the rows returned"""
    where: resources_bool_exp
  ): resources_aggregate!

  """fetch data from the table: "boat.resources" using primary key columns"""
  resources_by_pk(id: String!): resources

  """
  fetch data from the table: "boat.sessions"
  """
  sessions(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): [sessions!]!

  """
  fetch aggregated fields from the table: "boat.sessions"
  """
  sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): sessions_aggregate!

  """fetch data from the table: "boat.sessions" using primary key columns"""
  sessions_by_pk(id: String!): sessions

  """
  fetch data from the table: "boat.subtasks"
  """
  subtasks(
    """distinct select on columns"""
    distinct_on: [subtasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subtasks_order_by!]

    """filter the rows returned"""
    where: subtasks_bool_exp
  ): [subtasks!]!

  """
  fetch aggregated fields from the table: "boat.subtasks"
  """
  subtasks_aggregate(
    """distinct select on columns"""
    distinct_on: [subtasks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [subtasks_order_by!]

    """filter the rows returned"""
    where: subtasks_bool_exp
  ): subtasks_aggregate!

  """fetch data from the table: "boat.subtasks" using primary key columns"""
  subtasks_by_pk(id: String!): subtasks

  """
  fetch data from the table: "boat.test_table"
  """
  test_table(
    """distinct select on columns"""
    distinct_on: [test_table_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [test_table_order_by!]

    """filter the rows returned"""
    where: test_table_bool_exp
  ): [test_table!]!

  """
  fetch aggregated fields from the table: "boat.test_table"
  """
  test_table_aggregate(
    """distinct select on columns"""
    distinct_on: [test_table_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [test_table_order_by!]

    """filter the rows returned"""
    where: test_table_bool_exp
  ): test_table_aggregate!

  """fetch data from the table: "boat.test_table" using primary key columns"""
  test_table_by_pk(id: String!): test_table

  """
  fetch data from the table: "boat.transactions"
  """
  transactions(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): [transactions!]!

  """
  fetch aggregated fields from the table: "boat.transactions"
  """
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transactions_order_by!]

    """filter the rows returned"""
    where: transactions_bool_exp
  ): transactions_aggregate!

  """
  fetch data from the table: "boat.transactions" using primary key columns
  """
  transactions_by_pk(stripe_id: String!): transactions

  """
  fetch data from the table: "boat.units"
  """
  units(
    """distinct select on columns"""
    distinct_on: [units_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [units_order_by!]

    """filter the rows returned"""
    where: units_bool_exp
  ): [units!]!

  """
  fetch aggregated fields from the table: "boat.units"
  """
  units_aggregate(
    """distinct select on columns"""
    distinct_on: [units_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [units_order_by!]

    """filter the rows returned"""
    where: units_bool_exp
  ): units_aggregate!

  """fetch data from the table: "boat.units" using primary key columns"""
  units_by_pk(id: String!): units

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: String!): user

  """
  fetch data from the table: "boat.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "boat.users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "boat.users" using primary key columns"""
  users_by_pk(id: String!): users

  """
  fetch data from the table: "boat.vehicles"
  """
  vehicles(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): [vehicles!]!

  """
  fetch aggregated fields from the table: "boat.vehicles"
  """
  vehicles_aggregate(
    """distinct select on columns"""
    distinct_on: [vehicles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [vehicles_order_by!]

    """filter the rows returned"""
    where: vehicles_bool_exp
  ): vehicles_aggregate!

  """fetch data from the table: "boat.vehicles" using primary key columns"""
  vehicles_by_pk(id: String!): vehicles
